# React-Design-Patterns
React: Design Patterns

## Introduction
- [Take your React skills to the next level](#take-your-react-skills-to-the-next-level)
- [What should know](#what-should-know)
- [What are design patterns?](#what-are-design-patterns)

## 1. Layout Components
- [What are layout components?](#what-are-layout-components)
- [Split-screen components](#split-screen-components)
- [Split-screen component improvements](#split-screen-component-improvements)
- [List and list items](#list-and-list-items)
- [Creating different list types](#creating-different-list-types)
- [Modal components](#modal-components)

## 2. Container Components
- [What are container compoent](#what-are-container-component)
- [Server Instructions](#server-instructions)
- [CurrentUserLoad component](#currentuserload-component)
- [UserLoader component](#userloader-component)
- [ResourceLoader component](#resourceLoader-component)
- [DataSource component](#dataSource-component)
- [Loading data from localStorage](#loading-data-from-localStorage)

## 3. Controlled adnd Uncontrolled Component
- [Controlled vs. uncontrolled components](#controlled-vs-uncontrolled-components)
- [Uncontrolled forms](#Uncontrolled-forms)
- [Ccontrolled forms](#controlled-forms)
- [Controlled modals](#controlled-modals)
- [Uncontrolled onboarding flows](#uncontrolled-onboarding-flows)
- [Collecting onboarding data](#collecting-onboarding-data)
- [Controlled onboarding flows](#controlled-onboarding-flows)

## 4. Higher-Order Components
- [What are higher-order components?](#what-are-higher-order-components)
- [Printing props with HOCs](#printing-props-with-HOCs)
- [Loading data with HOCs](#loading-data-with-HOCs)
- [Modifying data data HOCs](#modifying-data-data-HOCs)
- [Creating forms with HOCs](#creating-forms-with-HOCs)
- [Higher-order component improvements](#higher-order-component-improvements)

## 5. Custom Hooks Patterns
- [What are custom Hooks?](#what-are-custom-hooks)
- [useCurrentUser Hook](#usecurrentUser-hook)
- [useUser Hook](#useuser-hook)
- [useResource Hook](#useResourcepHook)
- [useDataSource Hook](#usedataSource-hook)

## 6. Functional Programming and React
- [What is functional programming?](#what-is-functional-programming)
- [Recursive components](#recursive-components)
- [Component composition](#Component-composition)
- [Partially applied components](#partially-applied-components)

## Conculation
- [Next steps](#next-steps)


### Take your React skills to the next level
Maybe you're learned the basics of React and are wondering where to go next.<br>

Or maybe you're looking to make Reactt development more intuitive for your self so that you can build anything you can imagine.<br>

Well, whatever the case, learning and mastering React design patterns might just be the way to take your software development career to another level. <br>

I'am Uzzal Roy, and I'am a senior software developer and tech educator.<br>

The topics in this course represent many of the things that I look for when interviewing React developer candidates.<br>

Things that will take you from a begineer or intermediate level to an advanced level in React.<br>

Join me this course to learn React's most important design patterns, and see how to take your productivity and intuition in React to the next level.

### What should know
In order to get the most out of this course, there are a few things that it would be helpful for you to know beforehand.<br>

##### What You Should Already Know
- React basics
- React Hooks
- Making network requests in React
- Functinal programming(not required)

The first thing that it would be helpful for you to have is a basic experience with React, right? <br>

Just knowing the basics behind how to React works should be sufficent.<br>

You should also have some experience with React Hooks.<br>

Now, hooks being a more recent addition to the React Library.<br>

You might want to brush up on these before you start this course, since we'll be talking about those in detail.<br>

It would also be helpful for you to have some experience making network requests in React.<br>

And for this, if you haven't seen this already, I hight recommend my course on Full Stack Development with React.<br>

And finally, a little bit of experience with functional programming would be very helpful, but this is not something that's required for this course. <br>

So if you're missing one or more of these prerequisites, feel free to brush up on those beforehand. Otherwise let's get going.

### What are design patterns?
We're going to be learning quite a few different React design patterns, but before we get into that, I wat to talk a little bit about what design patterns are in the first place.<br>

#### Design Patterns:<hr>
Design patterns are effective solutions to common application development challenges.<br>

So the definition that I've come up with for design patterns is that design patterns are effective solutions to common application development challenges. <br>

And notice here that i have effective underlined, because there are a lot of solutions to different problems that are not effective and that lead to more brittle code down the line and make your apps less performant and less maintainable.<br>

Those are generally referred to as anti-patterns. <br>

So design patterns are the positive equivalent of thouse, right? <br>

So in other words, they're that most effective solutions to a given development challenge. <br>

We'll see what I mean later on in the course. <br>

#### A Caveat<hr>
The design patterns we talk about in this course are not the Gang of Four OOP design patterns.<br>

Now, one caveat before we move on is that many of you may have heard of design patterns used in a different context, such as object oriented programming. <br>

Well, the design patterns that we're going to be talking about in this course are not those. <br>

In other words, they're not the so-called Gang for Four object oriented programming design patterns, such as creational, behavioral patterns, et cetera. <br>

There's something a little bit different. <br>

- The patterns we cover here are effective solutons to some extremely common challenges in React.

Basically the patterns that we're going to be covering here are things that I've personally run into time and time again in basically every React application I;ve worked on. <br>

#### Common Challenges
- Creating reusable layouts

Some of these challenges include things like creating reusable layouts to put our components into, right? <br>

We'll see later on how to make things <br>

- Reusing complex logic between multiple components

Another challenge is how do we reuse complex logic between our component? <br>

In other words, if we have two or more components that need to do the same complex things such a load data from a server, <br>
how do we best represent that in our React apps so that <br>
we can share that code between those components<br>
instead of having to copy and paste it.<br>

- Working with forms

Another extremely common challenge is working with forms in React.<br>

This something that despite hundreds of articles out there on how to do this currectly, I still see done incorrectly quite frequently.<br>

So we'll be discussing how to do that in React.<br>

- Incorporating functional concepts into our code

And finally, we're going to see from functional programming into our React apps. <br>

This is something that I've been asked about quite frequently since my functional programming courses. <br>

And Im very excited to share it with you in this course. <br>

Well, those are some of the common challenges we're going to be taking a look at. <br>

So let's jump right into the first pattern.

### What are layout components?
We're going to talk about are something called layout components. <br>

#### Layout Components
React components that deal primarily with arranging other components on the page. <br>

Let's start off with a definition here Layout components are components in React whose primary concern is helping us to arrange other components that we create on the page. <br>

Some examples of this that you're probable familiar with, and that we're going to be taking a look at throughout the rest of this chapter are splite screens, right?

#### Layout Component Examples

- Splite Screens

So arranging more than one component in different sections of the page. <br>

- Lists and Items

We also have lists and items, right? So display data in a list, this is a surprisingle hard thing to get completely right. <br>

- Modals

And Modals, which as most of you know, is just content that gets displayed over top the actual page. <br>

#### The Idea of Layout Component

```
<div styles={...}>
    <h1>Component Code...</h1>
</div>
```
So here's the basic idea of layout components and how we're going to go about creating them. <br>

Normally, when we create a component, let's say we're creating a side nagivation for out site, right? <br>

Just a bar on the left-hand side that contains some links. <br>

The normal way we would go about doing that, as you can see in this code on theleft, is by actually including the div and the styles that go with that side nav inside the component itself. <br>

```
<div styles={...}>
    {children}
</div>
```

However, with layout components, what we do is splite the actual layout styles into the their own component, and then simply display the component itself, in this case, the side nav, inside that layout component. <br>
```
<>
    <h1>Component Code...</h1>
</>
```
And what this does is it separates the component itself from where the component's being displayed on the page, and it gives use a lot more flexibility for how we use it in the feture. <br>

#### The Idea of Layout Components
Out components shouldn't know where they're beign displayed. <br>

So with all that said, the main idea of layout components is that out components that we create, right, the main content components of out pages, shouldn't know or care where it is that they're actually being displayed on the page. <br>

So just keep that in mind that is the main idea of layout components.

### Split-screen components
- All right. 
So now that we know what basic layout components are, let's take a look at some good examples of this pattern. 
The first example we're going to take a look at here is creating a split screen using layout components. 
So we're going to start off this example with just a basic Create React App application. You can find this in the exercise files. Just make sure to run NPM install before using this. And the first thing we're going to do is for styling purposes, we're going to install a package called styled components. Now, I've talked about styled components in other courses of mine. If you're curious about those, feel free to look around the library for them. Essentially, styled components are just a very easy way to add styles to React components. You'll see what I mean in just a minute. So we're going to start off here by adding a new file that's going to contain our split screen layout component. So we're going to call this split screen dot JS, and here's what this component's going to look like. We're going to start off by defining the component itself. So we'll say export const split screen. And it's going to take a few props that will make sense in a minute. The first prop is going to be called left, and this is going to be the component that will be displayed on the left side of the split screen. And what we're going to do, just to keep in with React's convention of giving components capital letter names, we're going to actually rename this left prop to Left with a capital L. So that's why I'm doing that. And then we're going to do the same thing with right here. Okay? So we have two props, Left and Right, and that's all we need for now. So the body of our component now is going to be fairly simple. What we're going to do is return a div. Inside that div, we're going to have two other divs, which are going to be basically each side of our split screen, right? The left-hand side and the right hand side. And inside each of those, we're going to display the left- and right-hand components respectively. So we're going to say Left. Then we're going to do the same thing for the right-hand side by saying div, and putting a component called Right inside of there. All right. So currently all this does is wraps our left and right components inside some divs, so what we're going to need to do next is actually add some styles to those divs. Now, as I mentioned before, we're going to be using styled components for this. So let's import the styled components package, which works a little bit like this. We're going to say import styled from styled components. And then to use our styled components package to add styling to these divs, what we're going to do is add a new styled component called container. So we'll say const container equals styled dot div. And then inside back ticks, this is just the syntax that styled components uses to define its components, inside here we're going to define the styles that we want to apply to container. And that's going to look like this. All we're going to do is add display flex to it. And then under that, we're going to define another styled component called pane. This is going to be the styles that we apply to these two divs that are wrapping our Left and Right components. So we're going to say const pain equals styled dot div. We're going to use back ticks there as well. And for this one, the only style we're going to give it is flex one. Basically, that will make the left and right panes take up equal amounts of space. We'll see shortly how to make it so that we can change the amount of space that each side takes up. Okay, so now that we have our container and pane styled components, the way we add those to our split screen component is simply by replacing div with container... and pane. And we got to go through and change all of these to pane and container as well. Okay. So that's what that's going to look like now. And now that we've created our split screen component, let's see what it looks like displayed inside our app. So what we're going to do, again, this is just the starter code that Create React App provides us with. What we're going to do is just delete all of this inside of here, and just display our split screen component. So first, of course, we have to import it, and you can remove this logo and app dot CSS thing as well. We're going to import split screen from split screen. I'm just going to adjust the indentation there to fit my IDE. And then inside of here, we're going to say split screen. And then just to get an idea of how this works, we're going to pass two components, one to the left prop of our split screen, I'll show you what that looks like in a second, and one to the right prop. So for these left and right components, all we're going to do is inside our app component, we're going to define two very, very simple components. The first component we'll call left hand component. And what that's going to do is just return, I don't know, something like a H one heading that says left, and we'll do the same thing. We'll have a right-hand component... which is basically just going to return. We'll have it return a paragraph tag that says right. Okay. So now that we have our left-hand component and right-hand components, let's insert those into the left and right props. So we're going to say left-hand component... and right-hand component. And that should be all we need to do. So let's run this app by doing NPM run start, and again, make sure to run NPM install before you do this. And we should see that this opens up local host 3000 in our browser. And we see that sure enough, we have our left component and our right components displayed in their respective places on the screen. Now, if you want to make it more obvious what this split screen component is doing, you can also add some styles to our left-hand component and right-hand component. And to do that, you can either use styled components, like we did before, but since this is going to be a fairly simple example, all I'm going to do is pass a style prop to the H one tag in our left-hand component. And we'll say background color, and we'll just make it something very obvious. We'll just say green, for example. And then for our paragraph tag inside our right-hand component, we'll say style, and for the background color there... we'll make that red, okay? So now, if we save this and go back, we're going to see that our left-hand component is displayed on the left-hand side, and our right-hand component is displayed on the right-hand side.

### Split-screen component improvements
- All right. So now that we've seen how to implement a basic split screen component, I'm going to show you a few modifications that we can make to that component in order to make it a little more developer friendly. So the first thing we're going to see is how to add weight to different components displayed by our split screen. What I mean by that is we might want our left component to take up less space and our right component to take up more space or vice versa. Now, the way that we can do that is simply by adding two more props to our split screen component. The first one is going to be left weight, and we're going to give that a default value of one. And we'll also have right weight, which will also give a default value of one. Oh, and the syntax for that is left weight equals one and right weight equals one. Okay, so basically all we have to do now is just pass this left weight and right weight through to their respective pane components and then modify this flex property accordingly. So what that's going to look like, and this is just how it works with styled components, we're going to say weight equals left weight. And for our right pane, we're going to say weight equals right weight. All right. And then we just have to go up to our pane component here, and we're going to insert the value of that weight prop into the flex property. And the way we're going to do that, again, this is just the way it works with style components, so don't worry about the syntax here, is we're going to say props and we're going to map that to props dot weight. Okay, so in other words, whatever we pass in for left weight and right weight, will replace this here. So if we pass in one, it'll be flex one. If we pass in five, it'll be flex five, et cetera. Okay, so let's see how to use this. We're going to open up our app dot JS component now and add these two other props that we just created. So we're going to say left weight, and let's say that we want the left-hand side to be one third as large as the right hand side. Well, since the weight props that we've defined pretty much reflect how Flexbox works. Our left weight is going to be one and our right weight will be three. All right, so our left weight is going to be one third as wide as our right weight here. Okay, so let's take a look at our app now. And we see that the left-hand side of our split screen is now a third as wide as the right-hand side. So this would be good if we wanted to display something like a side nav of some sort. So we've seen how to add weight to the different items in our split-screen component. And the next optimization that I'm going to show you is that instead of passing in our left-hand component and right-hand component as props, it's possible with layout components to make them accept their children as children in the sense of react. Let me show you what I mean by that. Instead of passing left and right as props, okay, we're going to keep our left weight and right weight here, instead of passing our left and right components as props, we're actually going to put them inside our split-screen component as children. What that's going to look like is this, we're going to say left-hand component and right-hand component like that. And then in order to make this work with our split screen, we're going to need to open that up. And we're going to remove the left and right props here and replace that with the children prop. And then what we're going to do is down here in the body of our split screen component, we're going to say const. And since children is going to be an array in this case, containing all of the elements that we passed as children to our split-screen component, what we can do is say const left and right. And notice we're not using capital letters in this case, since these are elements and not components, we're going to say equals children. And then instead of left as a component, we're going to display left, just using the curly braces. And then for right, we're going to do the same thing. Okay, so we have left and right inside curly braces. And as we can see now, if we go back over to our app, nothing has changed except that this is generally considered to be more developer friendly, right? Being able to pass in components as children to a layout component instead of having to pass them in as props. And what this also allows us to do is for our left-hand component, if our left-hand component needs to accept props, let's say that it needs a name prop of some kind and our right-hand component takes a prop. Let's say message. Okay. And let's display those inside of there. So we'll say message and name. Okay. If we want to pass those props into our left and right-hand components now, we can just do that directly. So we can say name equals Shaun, for example, and for our right-hand component, we can say message equals hello. Okay. And we can see that that works just like we want it to, whereas if we were rendering these components inside our split-screen component and passing them through as props like before, we would have to actually pass those name and message props through our split-screen component to our left and right components respectively. So we would have to add something like this and say, right props equals blah, blah, blah. That would be an object. And the same thing with left props. And we would have to pass those directly to here. So this is just a much easier way to do it right. Saying left and right. And that allows us to pass props directly to it. And it's just considered to be a little more readable that way.

### List and list items
- All right, so the next design pattern that we're going to take a look at here with layout components is lists and list items. Now, to start off here in the exercise files, you're going to find something a little bit different. Inside the app component, we have an array of people data and an array of products data, and what we want to do is display this data inside several different kinds of lists. So I'm going to show you how to create some list and list item components that can help us do this most effectively. So, first of all, let's create a few different kinds of list items for the people and the product. We've got different data to display here, such as name, age, hair color in the people than we do with our products where we have name, price, description, et cetera. So let's start off by creating some list item components and we're actually going to create two different variations of list items for each type of resource. So let's create a folder for our people, and inside there, we're going to create a SmallPersonListItem.js and a LargePersonListItem.js. Okay, and we're going to do the same thing for our products. So let's create a product folder, we'll say products, and inside there, we're going to say SmallProductListItem.js and LargeProductListItem.js. All right, so let's go through real quick and implement each of these. First of all, we're going to start off with our small person list item, and we're not really going to add any styling to these. It's really just going to be small or large depending on the quantity of information that it displays. So for our small person list item, I'm just going to type this out real quick, we're going to say export, const, small person list item. It's going to take a person as a prop. It's going to get only the name and age from that person props, so we'll say const, name and age equals person. And then, what we're going to do is return a paragraph that says name, name, comma, age, and then we'll put in the person's age and we'll put years after that. So that's our small person list item. Now notice that this small person list item doesn't really contain any styling that would indicate it knows where it's being displayed. In other words, we could display the small person list item in a numbered list, in a very narrow list, in a very wide list, and we could use the styling in its parent component to determine how it gets displayed. We'll see that in more detail a little later on. For now, first, let's implement our large person list item. For that, I'm just going to copy and paste our small person list item into large person list item. We're going to have to change the name here and this one's going to display a little more information than the small person list item. What we're going to do is get the name, age, hair color, and hobbies, properties from the person, and we're going to display them like this. Now, we're going to display all of this inside a react fragment for the same reason that I mentioned before. We don't really want this large person list item to be determining its own styling, we want its parent component to be able to do that. So we're going to have the name displayed like this. We're just going to say name, inside an h3 tag. Under that, we're going to have a paragraph tag with the person's age, we'll say age, age years. Under that, we're going to have their hair color. So we say hair color and insert the hair color into the JSX there. And then under that, we're going to have an h3 heading that says hobbies, and we're going to display all of their hobbies here. Remember that hobbies is an array if you go back and look at the original data. So we're going to say hobbies, under that, we're going to put an unordered list and we're going to map the hobbies. So we're going to say hobbies.map and for each hobby, we're going to add a list item which we'll need a key, of course, that key is just going to be the hobby itself, and we'll insert the hobby string into that list item. So that's our large person list item and our small person list item. Now, before we go on to implementing the small product and large product list items, I want to actually create the list components themselves. So, currently, we've only been creating the actual list item components. So let's take a look at what the lists that are going to display these components are going to look like. Now, contrary to what you might be expecting where we might have a large person list and a small person list, and a large product list and a small product list, we're actually just going to have a single list component that can display all of these different list items. Let me show you how that works. Inside the source folder, we're going to create a new file and we'll call this regular list. I'll show you how to make other types of lists in a minute here. And here's what regular list is going to look like. We're going to say export, const, regular list, and this list is going to take the items that it should display. So it's taking a prop called items and it's also going to take a prop called resource name. So this is going to be either products, or people, or whatever kind of resource that this list is going to be displaying. You'll see how we use that in a second. Now, the final prop, and I'm going to just indent all of these for readability. The final prop here is going to be called item component. Now, this is going to be the actual component that we use to display each of the items in this items array prop that we're getting here. So just like we did with the left and right-hand components when we saw how to do a split screen, we're going to rename item component so that it's got a capital letter. This just keeps in with React's convention of capital letters at the beginning of their component names. And then for the body of the component, here's what it's going to look like. It's actually going to be very simple. We're just going to say return and inside some react fragments. We're going to map over all of the items and display one item component for each of them, passing it to the prop called resource name. That might sound a little confusing but here's what it looks like. We're going to say item.map. We're going to get the item and its index here. And then, we're going to display the item component and pass through the current item that we're looking at to the prop with the name of a resource name. And what that's going to look like, this might look a little confusing for you. First of all, we need to add a key, which is just going to be the index. Normally, you're not supposed to use index as keys but we're just going to do that for now. We're going to use the spread operator, so dot, dot, dot, and then we're going to spread an object with a key that's going to be that resource name prop that we had up above, and we're going to pass through item for that. So what this is going to change to, let's say that we pass in person as resource name, this is going to change to person equals item. So that's what that's going to change to. It's kind of a confusing syntax at first but it's something you'll get used to. So that is how our regular list component works. Oh and this should be items.map, not item.map. All right, so let's see how our regular list works now. Let's open up our App.js component and display two lists, one which is going to display all small person list items and one which is going to display all large person list items. All right, so down here in our app, we're going to remove this h1 tag that I put there. We're going to display our regular list, which my IDE is going to import for me automatically. And then for the props, we're going to say items equals people. Under that, we're going to say resource name equals person. Remember that this resource name is the name of the prop that our small person list item and large person list item are expecting. And finally, we're going to pass through the component that we want each of these people to be displayed inside of. So we're going to say item component equals and we're going to include one with our small person list item, which again is going to be imported automatically for me. So make sure you go up and do that if your IDE doesn't do that. And that's how the regular list works. So we have one regular list with our small person list item. Under that, let's display one with the large person list item, just to show you what's possible with that. We're going to say item component equals large person list item. And now, if we run our app, which you can again do with NPM run start, we're going to see that up here at the top, we have a list of our people with the small person list item component. And down below, we have the same list component displaying a completely different list. For all of the people, it's using the large person list item. And I just want to point out before we move on that the regular way of doing this is not to have this reusable list component. It's, instead, to create a large person list item list and a small person list item list that then display those components. So, as you can see, the way that we've done it here makes the regular list a lot more reusable. We're able to simply pass in the component that we want to be displayed as children of this list.

### Creating different list types
- Okay. So now that we've seen how to use our regular list component to display people, using two different item components, we're going to implement the same kind of components for displaying products, right? So we have our small product list item and large product list item. Let's just create some very simple components for those. So for a small product list item, here's what that's going to look like. We're going to say export const, small product list item, and that's going to take a single prop, which is going to be product, right? That's the product that it's supposed to display. And for our small item, we're just going to get the name and price of that product. We're going to say equals product. And under that, we're going to say return and simply display in an H3 heading. You can use basically whatever element you want here, but I'm going to use an H3 heading. We're going to say name and price with a dash in between them, okay. And again, what this is going to allow us to do is have the parent component, essentially, whatever kind of list is displaying this item, determine the overall styling instead of us, you know, putting some kind of styled div as a wrapper. So that's a small product list item, for the large product list item, we're just going to add a little bit more data. So we'll say export const, large product list item, equals, and we have the product as the prop. And we're going to get the name, price, description, and rating from that product prop. So we're going to say name, price, description, rating equals product. And we're going to display all of those inside a fairly simple UI. We're just going to wrap all of this inside of react fragment, and we're going to have an H3 heading with the products name, like that, under that we're going to have the price of the product. So we're just going to display price inside a paragraph tag. Under that, we're going to have an H3 heading that says description. All right, so under here will be where we display the description now. We're going to say paragraph description. And finally under that, we're going to say average rating and display the products rating, okay. So that's the large product list item, before we display these however, I want to show you how to create a different type of list. So earlier we created this regular list, which simply takes some items, a resource name, and a given component that we want to display , maps over the items and passes the correct props to whatever component we give it. Now, if we wanted to simply display our large product, small product list item, et cetera. Inside this regular list, all we would have to do, is change this regular list, change items to products, change the resource name to product and change the item component to either small product list item, or large product list item. All right, and it would be as simple as that, we don't have to create any extra components or anything. Now, what if we wanted to display, as I've said before, a different type of list. What if we wanted to display a list that automatically numbered all of its items, for example? Well, the way we would do that is by creating a similar component to our regular list that we created before. All right, we're going to create a new file and we'll call it numberedlist.js, okay. And the numbered lists is going to be very similar to the regular list. The main difference is that it's going to automatically display numbers, along with its items. All right, so it's going to take items, resource name, and item component. And then instead of simply displaying the item component inside this map here, we're going to wrap it in react fragments and above this here, we're going to have H3 and we're going to display the number of each item that we're displaying. Now, since I is the index, we're actually going to display I plus one, so that it starts at one and goes one, two, three, four, five, et cetera, okay. So now all we need to do, if we want to display, let's say the large person list item with a numbered list, we literally just change this to numbered list. And it's not importing that for me because I forgot to change the name of it inside of here. So we'll change that to numbered list. Let's try typing that again. There we go, and it imported it for me now. Okay, so if we want to display our large person list item with the numbered list, all we have to do is say numbered list instead of regular list. And if we want to display our large product list item with the numbered list, all we have to do is take that change people to products, change resource name, to product, and change large person list item to large product list item, which will also be important automatically. So if we go back now, we see that the numbered list worked just like we wanted it to. Now, I didn't add much styling here. If you want to do that yourself, feel free to go ahead and do that. And we see that the numbered list also worked with each of our product list items. So what you can see here, the point of all of this is that by creating just six different components, right. Our large and small person and product list items and our regular list and numbered list components. We were able to create a lot of different combinations, right? We were able to create a total of eight different combinations. If you assume regular and numbered for each of these small person list item, large person list item, et cetera. And that might not seem like a huge savings at first, but as your apps get larger and larger, this can really end up saving you a lot of time.

### Modal components
- All right, so we've seen how to do split screen components. We've seen how to do list components and list items. The last layout component that we're going to take a look at here is modals. Now, modals are obviously an incredibly popular thing to see in web applications. So let's see how to create them as another layout design pattern. The first thing we're going to do is create a new file here, which we'll call modal.js. And this is going to contain all of the code for our modal, obviously. Now, before I show you how to implement this component, I just want to say that when most people go to add modals to the react application, almost always the first thing they do is install, react modal, or a similar package like that, but that's really not necessary. And I'll show you why it's actually quite simple to implement your own. What we're going to do is we're going to say import use state from react. And we're also going to import styled from styled components. We're going to be using this to add the actual modal styling. And then our basic modal component is going to look something like this. We'll say export, const, modal, and we're going to basically get the children. This is going to be very similar to what we did with our split screen component. We're not going to pass in the modal contents as a prop. In other words, we're just going to display them, sort of like this. We're going to say modal, and then inside there some component. Inside, say the app component, okay. So this children prop allows us to do that. Now for the body of our component, we're going to have a state variable here called should show and set should show. And we're going to set that to false initially. So initially the modal is going to be hidden, okay. And then for the actual structure of the model, we're going to go up and create two different styled components. The first one is going to be called modal background, and that's going to be a styled div. So we'll say styled.div, and with back ticks, and we'll come back to the styles for that in just a minute. And then we're going to have another style component called modal body. So we'll say const modal body equals styled.div, and we'll come back and do both of those in just a second. First, I just want to show you what the JSX here is going to look like, with those styled components. We're going to basically just have the modal background here. Inside that is going to be the modal body and inside the modal body is going to be the actual children that we passed to this modal component. Now we're going to add a few more things. The first thing is that we only want the modal background, modal body, et cetera, to show when should show is true. So what that's going to look like, we're just going to use short circuit evaluation here to do that. We're going to say, should show and, and then with parentheses, we'll say modal background, modal body, et cetera. So in other words, all of these things are only going to show, if should show is true. And in order to actually get the modal to show up in the first place, we're going to put a button who's on click property, basically sets this should show state to true. So we're going to have a function here that says set should show to true. And the button is going to say something like show modal, okay. And in order to make react happy, we're going to have to wrap all of this in react fragments. This isn't so much for styling, mostly this button here that shows the modal is just to get the modal to show up in the first place. Later on in the course, we're going to see a better approach on how to do this, okay. Now, a few more things before our model will work like we want it to. The first thing is that when a user clicks on our modal background, we'll want it to hide the modal, right? This is pretty typical functionality in most modals. So we're going to say on click for that equals, and this is just going to say, set should show to false. And then inside the body of the modal itself, we're going to have another button that will actually allow the user to hide it. Normally this would just be an X button or something up in the top right-hand corner. We're just going to use a regular button for now that says hide modal. And for the on click method of that, we're going to set should show to false. So on click, set should show false, okay. And lastly, for our modal body here, we need to add an onclick event. And basically what this is going to do is call event.stop propagation. And basically the reason that we have to do this is whenever the user clicks on one of the children inside our component, we don't want that click event bubbling up and closing the modal, right? If we left this off, that's exactly what would happen whenever the user clicked on anything inside the modal, it would close the modal. So that's what our model needs to look like. Let's now add some of our styles. And in fact, the styles are not super complicated, but if you just want to copy and paste those from the end state of the exercise files, I would highly recommend that. In fact, that's what I'm going to do here, just to save us a little bit of time. So that's what the modal background is going to look like. It's just going to be a semi-transparent, dark gray background that covers the rest of the page. And for our modal body here, I'm just going to copy and paste those as well. It's basically just going to have a white background. It's going to take up 50% of the screen, have a little bit of margin, padding, et cetera. So that's our modal component, in order to demonstrate what this will actually look like, let's open up our app.JS. And just to show you, remember earlier, when we created our small person list item, large person list item, et cetera. I said that making those in such a way that they didn't contain their own styles would make them much more flexible in the future. Now I'm going to demonstrate how that's true by inserting one of those list items. Let's pick the large product list item, for example, and displaying that inside our new modal component, okay. So let's display our model here and inside that modal, we're going to display our large product list item. So we'll say large product list item. And for the prop here, that's just going to be product and we'll pass the first element of our product array up at the top, okay. So if we make sure that our app is running and head over here, we're going to click on show model, and sure enough, we'll see that the details of that product are now inside our modal, right? And you can click either on the background or on this hide modal button and it will hide the modal for us. All right, and obviously if we were going to use this large product list item for other things, besides list items, we might want to rename it to something like large product details, right? And that would make more sense. And that would allow us to basically display that now either in a list or in a modal, which is kind of the strong suit of layout components.


### What are container compoent
- Okay, so the next React design pattern that we're going to take a look at is something called Container Components. So what are container components exactly? Well, container components are basically React components that take care of all of the data loading and other data management for their child components. In order to show you what I mean with this, let's imagine that we have the setup that you see here, a container component with several child components inside of it. Well, normally what you would do, if you're like most beginning to Intermediate React Developers is you would just have each of those child components load their own data and then display it, right? So up where it says low data, you probably have a useState hook and a useEffect hook and use something like Axios or Fetch to get data from a server. Now, the problem with this is that a lot of the time we need our child components to be able to share that logic. And the way that container components solve that problem is by splitting that logic out into its own component, which is the container and the container then takes care of loading that data and passes it automatically to the children components. We're going to see how exactly this works very soon. So then the main idea of container components is this, just like how with layout components, we didn't want our child components to know or care what layout they were part of. With container components, we don't want our components to know where their data is coming from or how to manage it. We just want our components to be dumb and take some props and display whatever they need to display.

### Server Instructions
- Now that we've learned a little bit about what container components are exactly and their main goal, what we're going to do is take a look at a few examples that demonstrate how container components are used. The way we're going to go about this is we're going to start off with a fairly simple and not very re-usable example. Over the course of the next few videos, we're going to improve it and slowly make it more and more re-usable until we reach what I would consider a good stopping point. The first thing you're going to want to do here is get the starting state of the exercise files because it's different than the way we left it after we talked about layout components. Let's just discuss a few of the things that it contains. The first thing is this app component. There's not really anything in here. We've basically cleaned it all out of the code that we wrote before. Then we also have these UserInfo and ProductInfo components, which are basically just slightly-modified versions of the large person list item and large product list item components that we wrote previously. The main difference is that with our large person list item component, we've just changed the word person to user, because that's a more realistic scenario for most applications, is users. We have our UserInfo and ProductInfo components, which take a user and product prop separately. What we want to have these components do is display some data that we load from a server. That's the last file I wanted to talk about, is this server.js file that you'll find in the root directory of the exercise files. Basically, this is just a simple express server that will send back some data to our components. This is just to simulate a real-world, full-stack React app. We have the current user here. We have an array of all of the users on our site. There's only three of them as you can see, and we have an array of products. Then below that, we just have a few different endpoints that are going to send that data that we've looked at before back to our client side. We have a current user route for getting the information for the current user. We have a users ID route. Basically, this allows us to get an individual user by their ID. We have a post users ID, which allows us to modify users. We have a get all users endpoint, we have a get product by ID endpoint, and we have a get all products endpoint. Don't worry too much if you're not super familiar with backend development. You don't need to know all about express servers. I'll explain when we actually make requests to this server what each request is supposed to be doing. I'm going to close this server.js file since we won't be making any changes to it in this course. We're just going to use that as, basically, a mock that we're going to send requests to from our React application. But one thing you are going to want to do is know how to run that server. The way you're going to do that is by typing node and then the path to that file, which is just going to be server.js, provided that you're in the root directory. You should see that it says server is listening on port 8080. Just as a side note, you do need to run npm install in the exercise files directory before this will work.

### CurrentUserLoad component
- Okay, so you're going to want to leave the server running and open up a new terminal or just another tab in your existing terminal like I'm doing. And inside here, we're just going to run our react app by saying NPM run start. Oh, and one last thing I wanted to point out is that in order to make our front end and backend communicate with each other, I've also added a proxy to the package.json file. If you don't know what this is, don't worry about it for now. Okay, so we have our react app running. Obviously, there's not really very much going on here. So what we're going to do is, we're going to create a container component that will take care of loading the current user data, that's where we're going to start off here, and passing it to our user info component. So let's start off by creating that container component. Inside our source folder here, we're going to say new file, and we'll call this component CurrentUserLoader.js, because, again, it's going to take care of loading the data of our current user from the server. And here's what this component is going to look like. We're going to start off by saying export const current user loader. And the only prop that we're really going to care about for this container component is going to be the children prop. This is, again, all of the components that are inside the opening and closing tags of our current user loader component when we render it. And inside here, what we're going to do is have the basic react loading logic. So, anyone who's worked with full stack react before, or who's written a react app that interfaces with a third-party API will know that the way this is generally done is by using the use state and use effect hooks, which we import from react. And we're going to start off by saying const user set user equals use state, and the initial value for our user is going to be null. So basically, the user state is going to be null while we're loading our data. Okay. And then, we're going to actually load our data from the server by using this use effect hook. And we need to pass an empty array as a second argument to make sure that it only executes when it's first rendered. And inside here, we're going to create an async function, and this is just a shorthand version here for writing an anonymous async function. So inside here, we're going to say const response, and there are several different libraries or APIs that we can use to load data from a server. My personal preference is to use the Axios library. So that's what we're going to do here. And we need to install that first by saying NPM install Axios. If you haven't used Axios before, it's super simple to use, as you'll see. And we'll run our react app again. Okay. So now, we're going to import Axios from Axios and use that here to get a response from the server. So we're going to say await axios.get, and the end point that we're going to be loading our current user from, as I showed you a little earlier, is going to be /current-user. Okay. So now, this response is going to contain the data for the current user, which we can get by saying const current user equals response.data, and then saying set user current user. We could just shorten this as well by saying set user response.data. And now that we have our user data loaded from the server, all we have to do is pass this user state from our current user loader component down to all of its children components, which we're getting in the prop here. So, just to clarify what I mean by this, let's import our current user loader component. And we're also going to import our user info component, from user info. Okay, and what we want to do here is say current user loader, and inside the opening and closing tags of this component, we're going to have our user info component. And what is automatically going to happen, even though there's no props that we can see here, is our current user loader component is going to pass a user prop to our user info component, just because user info is one of its children. So here's how we make react do that. We're going to say return inside our current user loader component, and we're going to have just an opening and closing react fragment here. The syntax that we're about to use just requires us to do that. And then what we're going to do is, inside curly braces, we're going to say react.children.map children, and for each child that is inside this current user loader component, what we're going to do is say if that child is a valid react element, this is just for safety here, we're going to say, if react.isValidElement child, then we're going to return react.clone element child, and the second argument to this function allows us to specify extra props that we pass in to that child component. So in our case here, we're passing the user state that we have up here into that user prop of that child component. Otherwise, if it's not a valid react element, we're just going to return that child. And of course, we have to import react up at the top by saying import react. And that's all there is to it. So our current user loader component should work now, and this code that we wrote here should work as well. So let's give it a try. Let's open up our component and hit refresh. And what we're going to see is that we're getting this error that says cannot destructure property name of user, as it is null. The reason that this is currently happening is that inside our user info component, user is initially null while that data is loading. So there's a few ways that we can fix this. One way would simply be to provide a default value for user. Another way would be to check if user exists before returning this JSX, so we could say return user. And if the user exists, return all that. Otherwise, we could return loading. And this is actually what I'm going to leave it as, since this will work perfectly fine and it will also tell us when this current user is loading. So let's go back and refresh our application now. Ah, and we also need to add a default value here, so we can just say that. And that should fix it. Okay, so we see that now it's loaded John Doe from our server and it's displayed the information for this user inside the user info component that we had. And you can also see if you refresh that it very briefly shows that little loading paragraph tag.

### UserLoader component
- All right, so now that we've implemented this CurrentUserLoader, it's time for me to point out a few things that aren't quite right about it, or aren't quite ideal, at any rate. The main thing that's not ideal about our CurrentUserLoader is that it's very restricted in what it's capable of doing. Essentially, all this CurrentUserLoader does is load a single user and passes it to its children, and that single user is this currentUser that we're loading from the server. So what we're going to do, in this video, is modify our CurrentUserLoader component so that instead of just loading the currentUser, it's able to load any user we want by their ID. In fact, what we're going to do instead of modifying the CurrentUserLoader, we're just going to create a new file which we'll call UserLoader.js. And we're going to start off by just copying and pasting all of the code over from CurrentUserLoader into UserLoader. And, of course, changing the name of the component to UserLoader instead of CurrentUserLoader. Okay, now the main thing that we're going to change, about this UserLoader, is the URL that it's going to send a request to, right. When I showed you the server, we saw that the currentUser endpoint sent back just the data for the currentUser. And, just to show you that, let me open up the server and we can see that this currentUser, here, is what gets sent back in our currentUser endpoint, right, we're just sending back that currentUser object. So what we're going to do instead is send a request to this users/:id route, which allows us to get any user by their ID. So here's what that's going to look like. We're going to replace the endpoint that we're sending a request, here, to. We're going to use back ticks because we want to insert a value into this string. And we're going to say /users/, and then we want to insert the ID of the user that we want to load. Now the main problem, here, in this UserLoader component, is that we don't know what user ID we want. So what we're going to do is have the parent component, that's probably going to be the app component in our case, pass in the user ID as a prop. So we're going to have userId be a prop, along with children, and we're just going to insert that into the URL here. All right, and now that we've done that, we need to put userId into the array of useEffect, so that useEffect will run whenever this changes, although, in reality, it shouldn't. And then we're, actually, going to open up our server.js file. I may have mentioned earlier that we wouldn't be changing it, but that's not entirely true. And what we're going to do is add IDs, to these three users in our array, in order for everything to work. So we're just going to add some very simple IDs. The first one should be 123, the second one should be 234, and the third one we'll make 345, okay. And you can add one to the currentUser as well, if you want, we'll just make that 123, just like the user in this array, here, with the same name. And we're probably going to want to do the same thing for products, so we'll say products, we'll make these IDs four digits. So we'll have 1234, id: 2345, id: 3456, and that should make everything work just like we want it to. Okay, so now that we have this UserLoader component, which provides us with a little bit more flexibility than our CurrentUserLoader component, let's see how we can use it inside app.js. Okay, so we're going to import our UserLoader from UserLoader and we're going to replace CurrentUserLoader with UserLoader, and we're going to pass the userId as a prop to it. So we're going to say UserLoader userId, just to check, let's do 234. Okay, and we're going to change this closing tag to UserLoader as well. And one last thing we need to do, before this will actually work, I realized I didn't do it before, is since we've made changes to our server, we need to actually restart it in order for those IDs to take effect. Okay, so now we should be good to go. Let's head over and check in the browser. And we should see that Brenda Smith is, indeed, loaded from the server, right, because they are user 234. So what we can, actually, do with this UserLoader is we can reuse it several times over, right. And, of course, we're going to need to wrap this in React fragments like this. But what we can do is say we want user 123, we want user 234, and we want user 345, and each of these respective container components will load only that user with that ID and pass that different data to the same component, which will give us all of our users rendered in a, sort of, list here. If we wanted to, we could even say something like const userIds equals 123, 234, 345, and then just map these IDs and have UserLoader pass that ID and have UserInfo inside of it. I'm not going to do that here, but that would be something that you could definitely do.

### ResourceLoader component
- All right, so we refactored our current user loader into a more generic user loader that allows us to load different users instead of just the current user from our server. And this is a big step up from what we had before, but we can still take it a little further. What we're going to do, is instead of having a container component that loads a specific type of resource, we're going to have a generic component that allows us to load any type of resource from the server. So, here's what this is going to look like. We're going to start off by creating a new component and we're going to call this component resource loader, and we're actually going to copy some of our user loader code into here. Okay, so we're going to copy that, paste it in here, change the name of our component to resource loader, and there we go. So the first thing we're going to do with our resource loader component is instead of having a user ID as part of the props, we're going to have two other props. One is going to be the resource URL that we want to load data from, okay? So that would be slash users slash user ID. We're going to have the parent component pass that in instead. And the second one is going to be the resource name. This is going to be sort of similar to what we saw earlier in the course when we created our different list item components, okay? So we have a resource URL, resource name and children, and that's all we need for now. The next thing we're going to do, is change the name of our state here. Since it's no longer dealing just with users, we're just going to call the state state and set state. And instead of having the URL hard-coded here inside axios.get, we're going to just change that to axios.get resource URL, okay? And we're going to say set state to reflect that name change. And inside this use effect array, we're going to have to pass in resource URL just in case that changes, so our component will be able to reload the data, all right? And then we're going to keep this react.children.map thing, pretty much the same, except instead of just passing through a user prompts since user no longer exists, we're going to pass through a prop with the name equal to the resource name that we passed in. So if resource name is product, for example, this will be product, right? We're just going to specify resource name, and then the current value of the state. And that's pretty much all we need to change. So let's see how this is used now, by going back to our app component. And by the way, make sure that you're running both the server by running node server.js, and the react app by running NPM run start. And what we should be able to do now, is import our new resource loader component. We're going to say import resource loader from resource loader, and instead of having a user loader for each of these, I'm just going to replace all of these. Let's try loading some different types of resources. So for the first one, obviously just to see how it works, we can say resource loader and pass in the resource URL, which we can set to slash users slash one, two, three, for example. And the resource name, which would be user. And inside here, we have user info, okay? So this right here will have almost exactly the same functionality as we had before with our user loader, right? And we can see that that works just like before. However, it's a lot more flexible because now what we can do, is if we want to load some other server resource, like our products, we can do so by saying, resource loader, and then for the resource URL, we specify the URL of the products by saying slash product slash, and then the idea of one of our products, one, two, three, four is a good one here. And then the resource name is going to be product instead of user, okay? And then inside here, we can put our product info component, which we have to import. Up here, we're going to say import product info from product info. And if we go back to our app, it looks like we're going to have to make the same change to our product info component as we did to our user info component earlier, we're going to need to open that up. We're going to need to add a default value for product here, and we're going to want to check if the product exists before displaying it. So we're going to say product, or if it doesn't exist, we're going to display a loading message here, okay? So if we go back here now, we see that the resource loader component is working with both the user info component and with the product info components. So essentially we can use this container component resource loader to load any and all of the resources for their child components. And notice that this also saves us from having to copy and paste this kind of code between all the components that need it, right? That's one thing that I see quite often in react applications is just the same state and use effect over and over again, inside different components with only slightly different data needs. So as you can see here, we've pretty much solved that problem by making a reusable container component.

### DataSource component
- So we've seen how to make the concept of container components much more generic by creating this ResourceLoader component. That basically can load any resource we want from the server and automatically pass it to its child components, right? We saw how to have it load both users and products. And of course, it could load pretty much any other server resource that we wanted as well. Now, honestly, I would consider this a good stopping point for most applications. But just for fun, we're going to see how we might take this concept one step further and have a component that doesn't even know where its data is coming from. So to show you what I mean by this, I'm going to create a new file inside our source directory. And we're going to call this file DataSource.js. And this is going to be basically a container component, just like ResourceLoader. Except instead of starting off with the idea that we're going to be loading some resource from a URL on the server, this data source component, isn't going to know exactly where its data is coming from. So here's what this is going to look like. Instead of having this resource URL prop, we're going to have a prop called getDataFunction. And this is basically just going to be a function that will return whatever data the child components of our data source need. And we're going to leave this resource name thing here since we'll be needing it for the prop down below. But basically, the only change that we need to make here is instead of saying axios.get and passing a resource URL, And then what we're going to do is instead of specifically using Axios here to load data from our server, we're going to do something a little bit more generic. We're going to say const data equals await getDataFunction. And then we're just going to say setState data, okay? And we don't need this resource URL thing anymore, but we do need the getDataFunction just on the off chance that it changes. Although, it really has no reason to. So that's the only change that we need to make to our data source component. Now, let's see how this thing is actually going to work when we use it, okay? So what this is going to look like, let's start off by importing it. We're going to say import DataSource from DataSource. And we're going to replace our resource loaders here with a data source. And I'm going to start off by showing you how to replicate the functionality of our ResourceLoader using DataSource. Basically, what this is going to look like is we're just going to say DataSource and we're going to have our getDataFunction. And then for this getDataFunction, here's what that's going to look like. We're basically just going to have the code inside here that used to be inside our ResourceLoader, right? So we're going to say await axios.get. And we're going to return this response .data since our data source is basically just expecting this getDataFunction to return whatever data we eventually want to pass to its child component. So here's what that'll look like. We're going to start off, and this is going to be an asynchronous function by the way. We're going to say async. And we're going to say const response equals axios.get. For the URL, we'll just say users/123. And this needs an await as well. And then under that, we're just going to say return response.data, okay? So that's our getDataFunction. We also need the resource name, which in this case is going to be user. And then for the children, we're just going to have our user info component like that. And we also need to import Axios up at the top. So import Axios from Axios. And we should see now that this DataSource works just like our ResourceLoader did and our UserLoader did before it. And it basically does whatever we tell it in the getDataFunction. And passes that as a prop to all of the child components inside of it. So in the real world, here's how we might make this getDataFunction thing more simple. Since obviously, we don't want to have to pass in this big anonymous function every time we want to load data, right? So what we could do is just cut this out, create a function for it somewhere, right? We might say getServerData. And this would, of course, be an async function. We could specify the URL we wanted by saying URL and returning that function there like that. And then how we would actually use this thing is we would simply pass getServerData with the URL as the getDataFunction prop. And that would turn into this async function here with the corresponding URL. And we see that that still works.

### Loading data from localStorage
- So now that we've seen how to recreate the functionality that we already had with resource loader, let me show you how data source can go another step further. One thing that we might want to do is get some sort of message or something that's stored in our local storage instead of loading that data from a server. So what we could do in that case is we would define a corresponding function here to get server data. And we would call that something like get local storage data. Okay, and what this would be is a function that would take the key where something is stored in local storage in the user's browser. Return a function, and this doesn't need to be asynchronous since local storage isn't asynchronous. And we would just say return local storage dot, get item key. And then in order to use that, let's first of all, go and add something into our local storage. To do that you just have to open up the inspector window, go to application, and we're going to add an item by just double-clicking right under key here. And we'll add a message key. And the value for that will be something like hello from local storage. And it actually doesn't need those quotation marks since everything is by default, a string in local storage. So now what we can do just for the sake of example, I'm going to define a text component here, which takes a prop called message. That's what we'll be loading from local storage. And it's just going to return h1 with that message inside of it. You'll see how this comes together in just a minute. We're going to say data source, and what we're going to do now for the get data function, we're going to pass in, get local storage data. The key for that is going to be message. And the resource name here is going to be message as well. And then inside there, we'll have our text component that we just created. And this text component is automatically going to receive the contents of that piece of local storage in its prop called message. So what we're going to see if we go back here, we're going to see hello from local storage, which is our text component, getting its data from local storage via our data source component.

### Controlled vs. uncontrolled components
- [Instructor] All right, so the next React design pattern that we're going to take a look at is controlled and uncontrolled components. Now, this is a very, very common pattern to find in React, both of these, both controlled and uncontrolled components, so let's take a look at what both of these mean. First let's start off by defining uncontrolled components. Uncontrolled components are basically React components where the component itself keeps track of all its own internal state and really the only time we get data out of that component is when some event occurs. So this would be in the case of, let's say, a form when the user hits the Submit button. In an uncontrolled form, that would be the only time we actually know what values the inputs of that form contain. Controlled components, on the other hand, are basically components where their parent is the one that takes care of keeping track of the state and that state is then usually passed through to a controlled component as a prop of some sort. So those are just the basic definitions. Let's take a look at what this might look like in code. For uncontrolled components, more often than not, the component itself again is going to be the one that keeps track of its own state. So what this is going to look like up here at the top, we see that this component has its own useState hook and the only prop that it's getting past is this onSubmit prop, which the parent component would pass a function to to actually get the values of that component's state when the submit event is triggered. With controlled components, on the other hand, we see that our component no longer has that useState hook. In other words, the state of that component is passed through as props. And, of course, there's other kinds of functions that this component is going to use, as well. You'll see how this works very shortly when we take a look at some examples of this. So one question that comes up when we talk about uncontrolled and controlled components is which one do we generally prefer? Well, more often than not, we're going to prefer controlled components and there are several reasons for this. The main reason is that it just makes our components more reusable and it also makes them a lot easier to test since we can just set up a component with the exact state we want, instead of having to create the component manually, make some changes, and then trigger some event to find out what's going on inside of it. So in other words, controlled components are just easier to test, they're more reusable, we more often than not will prefer them.

### Uncontrolled forms
- [Instructor] All right, so now that we know some of the basic theory behind controlled and uncontrolled components, let's take a look at some examples of what they're going going to look like in code. Now we're going to start off by taking a look at forms since controlled and uncontrolled forms are the most commonly used types of components in React. So let's start off here by creating an uncontrolled form and we'll see exactly how that works. And before you get started here, make sure that you copy the starting state of the exercise files since it's a little different than how we left it off in the previous chapter. And you're also going to want to make sure you run NPM install before running your code. And just like before, we're going to run this app by running NPM run, start in the terminal. Okay, so we're going to start off by creating an uncontrolled form components. So let's add a new file to our project called uncontrolled form dot JS. And here's what an uncontrolled form in React is going to look like. Basically, this uncontrolled form is going to defer most of its logic to the actual DOM elements underneath. Let me show you what I mean, we're going to start off here by saying import React from 'react'. Then we're going to export our component here by saying export const uncontrolled form. And the JSX for this form is going to look like this. We're going to have a form inside that form. We're going to have several inputs. So let's just say that this form is collecting information about a user, right? So we'll have input, we'll have name equals name, type equals text, and we'll have a place holder here that says name, okay. And we're going to have several more inputs of different types. The one underneath that is going to be an age input, the type is going to be number. And the placeholder here will be age. Under that we're going to have hair color for the name. The type will be text, and the place holder will be hair color. And finally, we're going to have an input which is going to be the submit button. So we're going to say, we're going to remove the name. We're going to say type equals submit and value here. This is just going to be the text of this button is going to be submit, okay. So here is where the uncontrolledness of this form comes in. Basically, what we're going to do is our form is going to handle the on submit event. And for this, we're going to add a handle, submit function up here in our component. We'll say const handle submit. And inside here is the only place that we're really going to do any kind of logic with the values from our form. Now in order to actually get those values from our form, what we need to do is create some React Refs. And the way we do that is by saying something like const name input equals React dot create Ref. And then what we do is we pass this name input Ref as a prop to our input. So we would say something like ref equals name, input, and then we do the same thing for the other inputs that we need to get the value of. So we'll have an age input ref, and we'll have a hair color input ref, and we'll pass those as props to these other inputs. We'll say ref equals age input and ref equals hair color input. Okay, and then when this form is actually submitted, when the user clicks this submit button, what we do is we simply get the current values of those inputs by saying something like this, I'm just going to log it out to the console for now, we'll say console dot log name, input dot current dot value. And then we do the same thing for our other inputs as well. So we might have age input dot current dot value, and hair color input dot current dot value. And then we would want to say e dot prevent default because the default behavior of a form when we submit it is to refresh the page. And we also need to add e as an argument here, which is this the event that's occurring in this on submit handler. Okay, so that's our uncontrolled form. The way that we're going to use that in our higher component here would be to do something like this. We would say import uncontrolled form from uncontrolled form. And we would just display it in here like this, and let's go see what that will look like. We're just going to enter something in here and click submit. And if we open up our console here, oops, it looks like I misspelled on submit in our uncontrolled form here. There we go. Let's try that again and submit. And we'll see that sure enough, it logs out the values of those inputs. Now again, what makes this uncontrolled is that this component isn't really caring about what the values of each of these inputs is until some event occurs, right? Basically each of these inputs is just handling its own state until we submit the form. At which point we get all of the values.

### Controlled forms
- [Instructor] Okay, so now that we've seen what an uncontrolled form looks like, let's take a look at what a controlled form is going to look like and how it's different. So we're going to start off by creating a new file here, which we'll call ControlledForm.js. And our component is going to look like this. We're going to say export const ControlledForm equals, and then we'll have the body of our component. And the main difference with our controlled form is going to be that we're going to track the values of each of our forms inputs using a useState hook. So what this is going to look like, we're going to start off by importing the useState hook up here, import useState from react. And then inside our ControlledForm component, we're going to create state variables for all of the inputs that we're going to be inserting into our form. So we're going to say const name setName equals useState. And the starting value is going to be an empty string, const age, setAge equals useState. We'll just leave the initial value empty for that. And const hairColor, setHairColor equals useState, and the initial value for that will be an empty string. So now that we have these three different state variables, we're going to create our form in JSX. So we've got our form, inside that we're going to have a few inputs. So we're going to say input, the name for this first one will be name, the type will be text, the placeholder is going to be named just like we had before. Now, where this starts to differ from our uncontrolled form that we had before is we're going to actually pass in the value to each of these inputs. So the value for each of these inputs, that is the text that each input currently contains is going to be equal to the current value of the corresponding state variable. So the value of our name input is going to be equal to the name state. And the other thing that's different is that each of these inputs is going to have an onChange handler that will basically take care of updating each of these state variables whenever the user starts to change the value inside the text input, say by typing. So what this is going to look like is we're going to say e, that's the event by the way. And we're going to say setName to e.target.value. Basically what that's doing is it's setting the name state to the target value of this text input, basically whatever the user is trying to type in, or paste, or whatever. And that is what our inputs are going to look like in controlled forms. Just to make this a little more readable, I'm going to put each of these props on its separate line. Just a little easier to read there since we don't have the horizontal scroll. So that's our name input, let's define our age and hairColor inputs as well. This one here is going to have name equal to age. The type is going to be number. The placeholder is going to be Age. The value is going to be age. And for onChange we're going to say setAge to e.target.value. And since the value that we get from text inputs is always going be a string even when it's of type number, we're going to say number and explicitly convert that target value to a number. And finally, with our hairColor input, we're going to say name equals hairColor, type equals text, placeholder equals hairColor, and value equals our hairColor state. And for onChange, we're going to say setHairColor to e.target.value. And that's all we need to do. So again, what each of these inputs is doing, what our controlled form is doing that is, is it's creating a two-way binding between the value of each of these inputs and the value of each of these state variables. And I'll show you in just a second what that allows us to do. The last thing that our form needs, though before we do that, is just a button here that will say Submit. And generally when we're not relying on the onSubmit event, we just have a regular button inside of our form instead of a input of type submit. So that's what a controlled form looks like, but what are the benefits of this kind of thing? Well, the main benefit, the one that I use most often anyway, is that controlled forms allow us to do things like, form validation while the user is typing. In other words, before the user has tried to submit the form, we can give them feedback about the values that they've entered in. Let me show you how that's going to work. So, first of all, we're going to import the useEffect hook from react. And what we're going to do is we're going to have this useEffect hook listen for changes in any one of these state variables. The way we're going to do that is by saying useEffect. And we have our function here. And the second argument is going to be an array of values that we want to listen for. So we'll just start off with name. Basically what this means is that this useEffect hook here will fire whenever the value of name changes. So here's what we can do with that. Let's say that we want to show the user an error if their name is, let's say less than two characters long. Well, the way we would do that is inside this useEffect hook, we would say if name.length is less than two, then what we could do is say console.log, and just tell the user, Name must be two or more characters. Now, obviously showing errors in the browser console isn't what we would want to do in most cases, but this is just for example. So let's take a look at our application now and what we're going to see, oh, first we need to actually display the ControlledForm inside our app component. So let's import that. Say import ControlledForm from ControlledForm And we'll display our ControlledForm like that. And let's just refresh this and remove so that we're at localhost:3000. And let's start typing something into the name. So we can see that when the name is one character, we get this error printed out that says, name must be two or more characters. And then as we continue typing, it gets rid of that. Now, the way you would actually use this in a React app would look something like this. It'd probably have a state that would be something like, nameInputError, setNameInputError equals useState. And it would just be an empty string at first. And you could display that inside the form if you wanted to. So you could say nameInputError, and, and then you might just have a paragraph tag that displays it. So you would say nameInputError. And then if name.length is less than two, what you would do is you would say setNameInputError, and you could just display some kind of message like, Name must be two or more characters. And then you would add an else block to this if statement saying setNameInputError to nothing. So in other words, if the name is two or more characters, we don't want to show an error. And what this would look like if we go back to our application, is we see that immediately it's displaying name must be two or more characters. As soon as we input something that's valid, it gets rid of that error. So as you can see, controlled forms are really just much better for doing interactive stuff like that.

### Controlled modals
- [Instructor] Okay, the next example of uncontrolled and controlled components that we're going to take a look at is modals. Now, in this case, we actually already have an uncontrolled version of a modal component from earlier in the course when we created this modal. Now, this modal is uncontrolled. And the reason we say that is that the modal itself is the one that's controlling whether or not it's shown, and it also controls when it's hidden. And there's a few problems with this setup. The main problem is that none of the other components, right? For example, if we want to display this in our App component, which we can do by importing it here and displaying it here, refresh it there and we can take a look at it, okay? The problem is that the parent component really has no control over what this modal is doing. So let's say that we had another button on our page that we wanted to display the modal, right? Let's say that we had a button under here that says Show Modal or something like that. Well, there's really no way for this button now to make this modal display itself because, again, the modal is the only one that has control over its state. So what we're going to do here is take a look at how to transform this modal into a controlled modal that the parent component can actually manipulate in the way that it needs to. So, first of all, let's rename this Modal here to UncontrolledModal. We're going to rename it here, UncontrolledModal. Okay? And, of course, we'll change the name inside the file to UncontrolledModal. Change the import here to UncontrolledModal as well. And it looks like it already changed the file path for me. Okay, so let's create another modal called ControlledModal, right. We'll just put that in here, ControlledModal.js. We're going to copy and paste all of the code from our UncontrolledModal into there and make a few changes to it. So let's change the name first of all. Let's say ControlledModal. All right, and the main change we're going to make here is instead of having our ControlledModal use this useState hook to determine whether or not it should show, we're going to pass that in as a prop, so we'll say shouldShow, and remove the useState hook. Okay? So we don't even need to import it anymore. And we're also going to pass in a prop called onClose, right? Any of you who have used the react-modal library in the past maybe used to seeing this as onRequestClose, right? And that's probably a more accurate description of what this is doing, as you'll see. So, basically, what this is going to do is shouldShow is going to be a boolean that's passed in from the parent component. So the parent component is going to control whether the ControlledModal is shown or not, hence the name Controlled. And this onRequestClose function is going to allow the modal itself to request that the parent component stop showing it. Now, that will obviously only be one way that the parent component can stop showing it. The parent component will have the ultimate say over whether the modal shows up or not. Okay, so let's change all of these setShouldShow true things to just onRequestClose, right? They don't need to take any arguments or anything, as you'll see. I'm going to say onRequestClose and onRequestClose. Oh, and we don't even need this button anymore really since the parent component will be the one that displays the button that will actually show the modal. So let's remove that button there. And we can also shorten this up a little bit so that we just say return. If shouldShow is true, we're going to show all of that JSX. Otherwise, what we're going to do is simply return null from this component. There we go. So let's see what using this ControlledModal is going to look like now. Well, first of all, our App component is going to have to have a state that keeps track of whether the ControlledModal should be shown or not. So we'll import the useState hook here from react. We're going to display our ControlledModal here, which we'll have to import up at the top. We'll say import ControlledModal from ./ControlledModal. And then what we're going to do is define a prop up here that says something like shouldShowModal and setShouldShowModal equals useState, and we'll set that state to false, okay? And what we can do now is we can have this button outside the ControlledModal component determine whether the modal should be shown. So we're going to say onClick, we'll have that onClick event setShouldShowModal to the opposite of shouldShowModal. So it's basically toggling that state variable from true to false, or from false to true. And we can also use this shouldShowModal variable to determine the text of the button, right? Whether it's Show Modal or Hide Modal. So we can say something like shouldShowModal. If the modal's already showing, we want this to say Hide Modal. Otherwise, we want it to say Show Modal. And then what we need to do is just pass in some of the props to our ControlledModal. Remember that those props are going to be something like shouldShow equals shouldShowModal. We have an onRequestClose function, and basically what we're going to do here is just pass in a function that will set shouldShowModal to false, okay? And one other thing that we would be able to do here is we could display an alert or something like that that says, you know, "Are you sure?", that kind of thing before we actually allow it to close. But I'm not going to do that here, so we'll just set it to setShouldShowModal false. We can actually make that a lot smaller if we do it like that. And then, of course, we want to pass children to our ControlledModals. So let's remove this closing tag thing here. There we go. And we'll just have some kind of heading in there. We'll just say Hello for now. All right, so what this is going to look like now, let's head over to our application again. We might have to refresh it here. We're going to say Show Modal, and we can see that obviously the button changes to Hide Modal, although I'm realizing now that we can't really click on it here. But what we can do is click Hide Modal here, and that will call the onRequestClose prop of the modal which we've set in our App component to actually close the modal, okay? So that's what a controlled version of a modal is going to look like. Basically, the modal itself isn't taking care of handling anything about its state. The parent component is the one doing all of that.

### Uncontrolled onboarding flows
-  All right, the last example of controlled and uncontrolled components that we're going to take a look at is onboarding flows. Now an onboarding flow is basically just a component that displays different steps in an onboarding process. So step one might ask for the user's name, step two might ask for their age, step three might ask for their billing information, et cetera. So first let's start off by building an uncontrolled version of an onboarding flow. And after that, we'll see what it looks like if we convert that into a controlled version, and some of the benefits that that provides us with. So we're going to start off here by creating a new component, which we'll call uncontrolled onboarding flow. So we're going to say new file, uncontrolled onboarding flow dot JS, and here's what this is going to look like. We're going to start off by saying import React and useState from React. You'll see how we use those in a second. And our component is going to look like this. We'll say export const, uncontrolled onboarding flow, and it's going to take the children that we pass to it. You'll see what this looks like in just a minute. And it's also going to take an onFinish prop. Now this onFinish prop is basically just a function that's going to get called when the uncontrolled onboarding flow completes. In other words, when it's gone through all of its children that we pass to it, okay? So now we have the body of our component, which is going to look like this. We're going to start off by defining two different state variables. The first state variable is going to be called onboarding data. This state variable is basically going to contain all of the data that we collect from the user over the course of their onboarding. It's basically going to be an object with keys as you'll see in a minute. So we have onboarding data set onboarding data equals useState. The initial value is going to be an empty object. Again, you'll see what that looks like in a minute. And the second state variable we're going to define is going to be the current index of the step that we want to display, okay? So we're basically going to use this to determine which of the children that we pass to our onboarding flow is going to be shown, okay? And this is going to be useState. The initial value is going to be zero. So we're starting on the first child. And once we've done that, we're going to basically get the current child using the current index and this children prop. So that's going to look like this. We'll say const, current child equals React dot children, dot two array children. Basically, this just covers us in the case that children is only a single element where children wouldn't actually be an array, and then we're going to get the current index from children, okay. And before we move on to defining what the JSX of our component is actually going to look like, let's talk about how we're actually going to use this uncontrolled onboarding flow component, basically what it's going to look like. And I'm just going to remove all of the other components that we're not going to be using now, okay? And we'll import our uncontrolled onboarding flow from uncontrolled onboarding flow and display it like this. So basically what this is going to look like is inside our uncontrolled onboarding flow, we're going to have several other components each of which represents a step in the onboarding flow. So what I'm going to do is just define a few very simple components. We'll say const, step one. And we'll return a very simple component that just says step one. And then we'll do steps two and three as well. So we'll have step two, which we'll say step two and step three, which we'll say step three, there we go. So we're going to basically display these step components inside the uncontrolled onboarding flow like this step one, step two, and step three. And our uncontrolled onboarding flow is basically going to control, which of these components actually gets displayed on the page. In other words if the current index is one, it's going to display step two. If the current index is zero it'll display, step one, you get the idea. And let's also remove this should show modal thing here. We don't need that anymore, okay. So now that we know how our uncontrolled onboarding flow component is actually going to work with other components, basically all we need to do is return the current child. Now, the problem with this, this will work if we take a look at this, we'll see that it's displaying only step one, right? Since the current index starts off on zero, but the components themselves steps one, two, and three, don't actually have any way to go to the next step. So there's two ways we could do this one way would be to simply give our uncontrolled onboarding flow. The ability to do that. Let me show you what I mean. We could say return inside React fragments here. We're going to say current child. And then underneath the current child, we could have previous and next buttons. So we could say button previous, and button next, okay. And what that would do essentially is give us the ability to change those there. Basically either by adding one to the current index or subtracting one from the current index, okay. But that's not the approach that I'm actually going to take. The approach that I'm going to take is to pass a prop to each of the children that they can then access. This is similar to what we did with container components. So basically each of these components is going to have access to a prop called something like go to next, which will be a function that they can call to tell the uncontrolled onboarding flow to go to the next step in the onboarding process, okay. So we're going to say, go to next, go to next, go to next. And for each of these components, we're basically going to have it look like this. We'll have a React fragment, and we'll have a button that says on click equals go to next, all right. And we'll do that for all of our steps. So I'm just going to copy and paste step one for steps, two and three, like that. Say step two change this to step two, and step three and change this to step three, okay. And the way that these components are actually going to get this go-to next prop is inside our uncontrolled onboarding flow we're going to define it. So we'll say const, go to next. We'll define that in just a second, but the way this is going to work, just like with container components, we're going to say if React.is valid element, current child, we want to clone that child, and add this go to next function as a prop. So we're going to say return React dot clone element, current child, and the extra prop is going to be this go to next function. And then we'll say return current child. All right and for now, what we're going to do is just have go-to next increment, the current index by saying set current index to current index plus one. All right, so we'll see that this should work if we click on it, obviously when we exceed the index bounds, it doesn't show anything.

### Collecting onboarding data
- [Instructor] Okay. So that's the beginning of our uncontrolled onboarding flow. Next let's take a look at how to work with this onboarding data thing. Basically the onboarding data is just going to contain the data that we've collected in each of our steps. So the first thing we're going to do is modify our go to next function here so that it allows each component, right, each step in the onboarding flow, to pass in some kind of data to it. Okay, so we're going to have an argument here that will be called step data. And the step data is basically just going to be an object that contains some keys and values, whatever keys and values the current step needs to add to the state. You'll see what that looks like in just a second. So let's change the body of our go to next function a little bit. First, what we're going to do is say const next index equals current index plus one. All right. And then we're going to calculate the updated data from our existing onboarding data, and the data that the new step is trying to add. So we'll say const updated data equals dot dot dot onboarding data dot dot data step data, basically just combining those two objects together. Okay. And just for visibility, let's log out this updated data. We'll say console dot log updated data. And then what we're going to do is check if this next index is in the bounds of how many children we have by saying if next index is less than children dot length. If it is, we're going to say set current index to next index. Otherwise what we're going to do is call this on finish prop with the onboarding data that we've accumulated. So we're going to say else on finish updated data. Okay. And we're going to change the set current index here. We don't need that anymore, so we'll just delete it. This is going to be set onboarding data to updated data. All right, so the way this is going to work is each of our steps now is going to call go to next with some object containing whatever data they want to add to the onboarding state. So let's say that step one was supposed to collect the user's name. You can go ahead and add an input there if you want, and a state. Just for simplicity's sake, what I'm going to do is say anonymous function go to next, and we're going to pass an argument there that says name John Doe. For step two, let's say that step two was supposed to collect the user's age. Again, feel free to add an input there and actually do that. But for simplicity, I'm going to just say go to next, and pass age 100. And let's say that step three was supposed to get their hair color. So what we're going to do is say go to next... Hair color brown. All right. So we have our three steps. Each one of those is adding its own data to the onboarding state. And the last thing we're going to do is pass a prop to uncontrolled onboarding flow called on finish. And basically when our flow finishes, what we're going to do is just console log all of the data. And maybe we'll also display an alert saying that you finished onboarding, or something like that. So we'll say alert onboarding complete. All right. So let's see what this looks like. We're going to go back here and click on next. Oh, and let's open up our inspector window so that we can see how the state updates as we go along. So we can see right now that the state now has a property name equal to John Doe that was added by step one. We're going to click next on step two, which will add the age to the onboarding state. All right, so we see that this is what the onboarding state looks like now. And finally, we're going to click on next on step three, which will log out the updated state, as well as display onboarding complete, all right? So one of these, keep in mind, is coming from the go to next function. The other one is coming from the on finish function that we have here, so we're console logging that data. Now again, this onboarding component is considered to be uncontrolled because the app component that's displaying it really has very little control over what it's doing. So again, let's say that we wanted to show and hide certain steps based on the data contained in the uncontrolled onboarding flow. Currently, there's really no way to do that, and that's why we're going to take a look at how to make this onboarding flow controlled.

### Controlled onboarding flows
- [Instructor] Okay, so we've seen how to create an uncontrolled onboarding flow component. Let's take a look at how we can convert this component into a controlled component. So the first thing we're going to do is create a new file for our controlled onboarding flow component, which we'll, of course, call ControlledOnboardingFlow.js. And inside here, what we're going to do is copy and paste all of the code from our uncontrolled onboarding flow. And we'll start off by changing the name here to Controlled Onboarding Flow. And just like we saw with our modal component, the main change we're going to make here is, instead of keeping track of the onboarding data and current index inside the onboarding flow itself, we're going to pass those things in as props from the parent component. So in addition to having children and on finish as props, it's also going to take a current index prop and an on next prop. All right, so you'll see how the onboarding data and current index change here. We're going to remove these two state variables and we can get rid of use state here as well. And the next thing we're going to do is, instead of having all this go to next logic inside our controlled onboarding flow, we're going to move that up into the parent component, which, in our case, is going to be the app component. So let's copy that, and we'll paste it in here. And we're also going to need to add some state variables to our app component. So let's import our use state hook from react, and we're going to create the same two state variables that we had inside our uncontrolled onboarding flow. In fact, we can just copy and paste those from there, actually. We're just going to copy these two, put them in our app component. And we'll come back and fix some of the stuff in go to next in a minute. But what we're going to do first is change this from uncontrolled onboarding flow to controlled onboarding flow. Okay, controlled onboarding flow. And we're also going to simplify this go to next thing here. What we're going to do is simply say set onboarding data to current onboarding data, so onboarding data and step data, we're just using the spread operator there to combine those two. And under that, we're going to say set current index to current index plus one. Okay. And let's also change the name of go to next to just on next, and we'll pass it to our controlled onboarding flow. So we're going to delete those props there. We're going to pass in the current index, since we have that as a state variable now in our app component, so current index equals current index. Oops, I imported something accidentally. And we're also going to pass on next to the on next prop of our controlled onboarding flow. And then, what we're going to do is really simplify the go to next function from our controlled onboarding flow. We're going to remove the entire body and change that to simply call the on next function that we're getting passed in as a prop here. So we'll say on next and call that with the step data. And this go to next, of course, is getting passed to all the children, so that's going to work exactly the same way, and we should be good to go now. If we go back to our app and click on Next, we should see that it works just like before. Now, the benefit of having this as a controlled component, as I mentioned before, is that it gives us much more control over certain changes that we might want to make to the onboarding flow. So as an example, we're collecting the user's name, age, and hair color. What if, based on their age, we wanted to tell the user whether they qualified for our site's senior discount or something like that. Well, here's what that would look like. I'm going to add another step in between the old step three and step two, we're going to change this last one to step four. Okay, and in step three, we're not going to pass anything to go to next. We're just going to pass an empty object here. And we're going to say something like, "congratulations, "you qualify "for our "senior discount," something like that. Now, we obviously don't want to show this step to users who are under a certain age. I think in America, it's 62 or something like that. So what we can actually do, because our app component now has access to the current state of the onboarding, what index it's on and the onboarding data, what we can do is, we can only display step three if a certain condition is met. In our case here, and we're going to add step four there as well, in our case here, we can say something like if onboardingData.age is greater than or equal to 62, then we want to show step three. Otherwise, we want to skip straight to step four. So what's going to happen now, because we're setting age to 100 in step two, we should see step three show up. So I'm going to just refresh this so we go back to step one and I'm going to click Next, Next, and we, of course, see step three and click Next and go to step four. However, if we change this now to something less than 62, if we say 50, for example, and refresh, we're going to see that we'll skip straight over step three. So essentially, what this controlled onboarding flow gives us is much more flexibility over what our onboarding flow looks like and how it changes as we go on.

### What are higher-order components?
### Printing props with HOCs
### Loading data with HOCs
### Modifying data data HOCs
### Creating forms with HOCs
### Higher-order component improvements

### What are custom Hooks?
### useCurrentUser Hook
### useUser Hook
### useResource Hook
### useDataSource Hook

### What is functional programming?
### Recursive components
### Component composition
### Partially applied components

### Next steps
