# React-Design-Patterns
React: Design Patterns

## Introduction
- [Take your React skills to the next level](#take-your-react-skills-to-the-next-level)
- [What should know](#what-should-know)
- [What are design patterns?](#what-are-design-patterns)

## 1. Layout Components
- [What are layout components?](#what-are-layout-components)
- [Split-screen components](#split-screen-components)
- [Split-screen component improvements](#split-screen-component-improvements)
- [List and list items](#list-and-list-items)
- [Creating different list types](#creating-different-list-types)
- [Modal components](#modal-components)

## 2. Container Components
- [What are container compoent](#what-are-container-component)
- [Server Instructions](#server-instructions)
- [CurrentUserLoad component](#currentuserload-component)
- [UserLoader component](#userloader-component)
- [ResourceLoader component](#resourceLoader-component)
- [DataSource component](#dataSource-component)
- [Loading data from localStorage](#loading-data-from-localStorage)

## 3. Controlled adnd Uncontrolled Component
- [Controlled vs. uncontrolled components](#controlled-vs-uncontrolled-components)
- [Uncontrolled forms](#Uncontrolled-forms)
- [Ccontrolled forms](#controlled-forms)
- [Controlled modals](#controlled-modals)
- [Uncontrolled onboarding flows](#uncontrolled-onboarding-flows)
- [Collecting onboarding data](#collecting-onboarding-data)
- [Controlled onboarding flows](#controlled-onboarding-flows)

## 4. Higher-Order Components
- [What are higher-order components?](#what-are-higher-order-components)
- [Printing props with HOCs](#printing-props-with-HOCs)
- [Loading data with HOCs](#loading-data-with-HOCs)
- [Modifying data data HOCs](#modifying-data-data-HOCs)
- [Creating forms with HOCs](#creating-forms-with-HOCs)
- [Higher-order component improvements](#higher-order-component-improvements)

## 5. Custom Hooks Patterns
- [What are custom Hooks?](#what-are-custom-hooks)
- [useCurrentUser Hook](#usecurrentUser-hook)
- [useUser Hook](#useuser-hook)
- [useResource Hook](#useResourcepHook)
- [useDataSource Hook](#usedataSource-hook)

## 6. Functional Programming and React
- [What is functional programming?](#what-is-functional-programming)
- [Recursive components](#recursive-components)
- [Component composition](#Component-composition)
- [Partially applied components](#partially-applied-components)

## Conculation
- [Next steps](#next-steps)


### Take your React skills to the next level
Maybe you're learned the basics of React and are wondering where to go next.<br>

Or maybe you're looking to make Reactt development more intuitive for your self so that you can build anything you can imagine.<br>

Well, whatever the case, learning and mastering React design patterns might just be the way to take your software development career to another level. <br>

I'am Uzzal Roy, and I'am a senior software developer and tech educator.<br>

The topics in this course represent many of the things that I look for when interviewing React developer candidates.<br>

Things that will take you from a begineer or intermediate level to an advanced level in React.<br>

Join me this course to learn React's most important design patterns, and see how to take your productivity and intuition in React to the next level.

### What should know
In order to get the most out of this course, there are a few things that it would be helpful for you to know beforehand.<br>

##### What You Should Already Know
- React basics
- React Hooks
- Making network requests in React
- Functinal programming(not required)

The first thing that it would be helpful for you to have is a basic experience with React, right? <br>

Just knowing the basics behind how to React works should be sufficent.<br>

You should also have some experience with React Hooks.<br>

Now, hooks being a more recent addition to the React Library.<br>

You might want to brush up on these before you start this course, since we'll be talking about those in detail.<br>

It would also be helpful for you to have some experience making network requests in React.<br>

And for this, if you haven't seen this already, I hight recommend my course on Full Stack Development with React.<br>

And finally, a little bit of experience with functional programming would be very helpful, but this is not something that's required for this course. <br>

So if you're missing one or more of these prerequisites, feel free to brush up on those beforehand. Otherwise let's get going.

### What are design patterns?
We're going to be learning quite a few different React design patterns, but before we get into that, I wat to talk a little bit about what design patterns are in the first place.<br>

#### Design Patterns:<hr>
Design patterns are effective solutions to common application development challenges.<br>

So the definition that I've come up with for design patterns is that design patterns are effective solutions to common application development challenges. <br>

And notice here that i have effective underlined, because there are a lot of solutions to different problems that are not effective and that lead to more brittle code down the line and make your apps less performant and less maintainable.<br>

Those are generally referred to as anti-patterns. <br>

So design patterns are the positive equivalent of thouse, right? <br>

So in other words, they're that most effective solutions to a given development challenge. <br>

We'll see what I mean later on in the course. <br>

#### A Caveat<hr>
The design patterns we talk about in this course are not the Gang of Four OOP design patterns.<br>

Now, one caveat before we move on is that many of you may have heard of design patterns used in a different context, such as object oriented programming. <br>

Well, the design patterns that we're going to be talking about in this course are not those. <br>

In other words, they're not the so-called Gang for Four object oriented programming design patterns, such as creational, behavioral patterns, et cetera. <br>

There's something a little bit different. <br>

- The patterns we cover here are effective solutons to some extremely common challenges in React.

Basically the patterns that we're going to be covering here are things that I've personally run into time and time again in basically every React application I;ve worked on. <br>

#### Common Challenges
- Creating reusable layouts

Some of these challenges include things like creating reusable layouts to put our components into, right? <br>

We'll see later on how to make things <br>

- Reusing complex logic between multiple components

Another challenge is how do we reuse complex logic between our component? <br>

In other words, if we have two or more components that need to do the same complex things such a load data from a server, <br>
how do we best represent that in our React apps so that <br>
we can share that code between those components<br>
instead of having to copy and paste it.<br>

- Working with forms

Another extremely common challenge is working with forms in React.<br>

This something that despite hundreds of articles out there on how to do this currectly, I still see done incorrectly quite frequently.<br>

So we'll be discussing how to do that in React.<br>

- Incorporating functional concepts into our code

And finally, we're going to see from functional programming into our React apps. <br>

This is something that I've been asked about quite frequently since my functional programming courses. <br>

And Im very excited to share it with you in this course. <br>

Well, those are some of the common challenges we're going to be taking a look at. <br>

So let's jump right into the first pattern.

### What are layout components?
We're going to talk about are something called layout components. <br>

#### Layout Components
React components that deal primarily with arranging other components on the page. <br>

Let's start off with a definition here Layout components are components in React whose primary concern is helping us to arrange other components that we create on the page. <br>

Some examples of this that you're probable familiar with, and that we're going to be taking a look at throughout the rest of this chapter are splite screens, right?

#### Layout Component Examples

- Splite Screens

So arranging more than one component in different sections of the page. <br>

- Lists and Items

We also have lists and items, right? So display data in a list, this is a surprisingle hard thing to get completely right. <br>

- Modals

And Modals, which as most of you know, is just content that gets displayed over top the actual page. <br>

#### The Idea of Layout Component

```
<div styles={...}>
    <h1>Component Code...</h1>
</div>
```
So here's the basic idea of layout components and how we're going to go about creating them. <br>

Normally, when we create a component, let's say we're creating a side nagivation for out site, right? <br>

Just a bar on the left-hand side that contains some links. <br>

The normal way we would go about doing that, as you can see in this code on theleft, is by actually including the div and the styles that go with that side nav inside the component itself. <br>

```
<div styles={...}>
    {children}
</div>
```

However, with layout components, what we do is splite the actual layout styles into the their own component, and then simply display the component itself, in this case, the side nav, inside that layout component. <br>
```
<>
    <h1>Component Code...</h1>
</>
```
And what this does is it separates the component itself from where the component's being displayed on the page, and it gives use a lot more flexibility for how we use it in the feture. <br>

#### The Idea of Layout Components
Out components shouldn't know where they're beign displayed. <br>

So with all that said, the main idea of layout components is that out components that we create, right, the main content components of out pages, shouldn't know or care where it is that they're actually being displayed on the page. <br>

So just keep that in mind that is the main idea of layout components.

### Split-screen components
- All right. 
So now that we know what basic layout components are, let's take a look at some good examples of this pattern. 
The first example we're going to take a look at here is creating a split screen using layout components. 
So we're going to start off this example with just a basic Create React App application. You can find this in the exercise files. Just make sure to run NPM install before using this. And the first thing we're going to do is for styling purposes, we're going to install a package called styled components. Now, I've talked about styled components in other courses of mine. If you're curious about those, feel free to look around the library for them. Essentially, styled components are just a very easy way to add styles to React components. You'll see what I mean in just a minute. So we're going to start off here by adding a new file that's going to contain our split screen layout component. So we're going to call this split screen dot JS, and here's what this component's going to look like. We're going to start off by defining the component itself. So we'll say export const split screen. And it's going to take a few props that will make sense in a minute. The first prop is going to be called left, and this is going to be the component that will be displayed on the left side of the split screen. And what we're going to do, just to keep in with React's convention of giving components capital letter names, we're going to actually rename this left prop to Left with a capital L. So that's why I'm doing that. And then we're going to do the same thing with right here. Okay? So we have two props, Left and Right, and that's all we need for now. So the body of our component now is going to be fairly simple. What we're going to do is return a div. Inside that div, we're going to have two other divs, which are going to be basically each side of our split screen, right? The left-hand side and the right hand side. And inside each of those, we're going to display the left- and right-hand components respectively. So we're going to say Left. Then we're going to do the same thing for the right-hand side by saying div, and putting a component called Right inside of there. All right. So currently all this does is wraps our left and right components inside some divs, so what we're going to need to do next is actually add some styles to those divs. Now, as I mentioned before, we're going to be using styled components for this. So let's import the styled components package, which works a little bit like this. We're going to say import styled from styled components. And then to use our styled components package to add styling to these divs, what we're going to do is add a new styled component called container. So we'll say const container equals styled dot div. And then inside back ticks, this is just the syntax that styled components uses to define its components, inside here we're going to define the styles that we want to apply to container. And that's going to look like this. All we're going to do is add display flex to it. And then under that, we're going to define another styled component called pane. This is going to be the styles that we apply to these two divs that are wrapping our Left and Right components. So we're going to say const pain equals styled dot div. We're going to use back ticks there as well. And for this one, the only style we're going to give it is flex one. Basically, that will make the left and right panes take up equal amounts of space. We'll see shortly how to make it so that we can change the amount of space that each side takes up. Okay, so now that we have our container and pane styled components, the way we add those to our split screen component is simply by replacing div with container... and pane. And we got to go through and change all of these to pane and container as well. Okay. So that's what that's going to look like now. And now that we've created our split screen component, let's see what it looks like displayed inside our app. So what we're going to do, again, this is just the starter code that Create React App provides us with. What we're going to do is just delete all of this inside of here, and just display our split screen component. So first, of course, we have to import it, and you can remove this logo and app dot CSS thing as well. We're going to import split screen from split screen. I'm just going to adjust the indentation there to fit my IDE. And then inside of here, we're going to say split screen. And then just to get an idea of how this works, we're going to pass two components, one to the left prop of our split screen, I'll show you what that looks like in a second, and one to the right prop. So for these left and right components, all we're going to do is inside our app component, we're going to define two very, very simple components. The first component we'll call left hand component. And what that's going to do is just return, I don't know, something like a H one heading that says left, and we'll do the same thing. We'll have a right-hand component... which is basically just going to return. We'll have it return a paragraph tag that says right. Okay. So now that we have our left-hand component and right-hand components, let's insert those into the left and right props. So we're going to say left-hand component... and right-hand component. And that should be all we need to do. So let's run this app by doing NPM run start, and again, make sure to run NPM install before you do this. And we should see that this opens up local host 3000 in our browser. And we see that sure enough, we have our left component and our right components displayed in their respective places on the screen. Now, if you want to make it more obvious what this split screen component is doing, you can also add some styles to our left-hand component and right-hand component. And to do that, you can either use styled components, like we did before, but since this is going to be a fairly simple example, all I'm going to do is pass a style prop to the H one tag in our left-hand component. And we'll say background color, and we'll just make it something very obvious. We'll just say green, for example. And then for our paragraph tag inside our right-hand component, we'll say style, and for the background color there... we'll make that red, okay? So now, if we save this and go back, we're going to see that our left-hand component is displayed on the left-hand side, and our right-hand component is displayed on the right-hand side.

### Split-screen component improvements
- All right. So now that we've seen how to implement a basic split screen component, I'm going to show you a few modifications that we can make to that component in order to make it a little more developer friendly. So the first thing we're going to see is how to add weight to different components displayed by our split screen. What I mean by that is we might want our left component to take up less space and our right component to take up more space or vice versa. Now, the way that we can do that is simply by adding two more props to our split screen component. The first one is going to be left weight, and we're going to give that a default value of one. And we'll also have right weight, which will also give a default value of one. Oh, and the syntax for that is left weight equals one and right weight equals one. Okay, so basically all we have to do now is just pass this left weight and right weight through to their respective pane components and then modify this flex property accordingly. So what that's going to look like, and this is just how it works with styled components, we're going to say weight equals left weight. And for our right pane, we're going to say weight equals right weight. All right. And then we just have to go up to our pane component here, and we're going to insert the value of that weight prop into the flex property. And the way we're going to do that, again, this is just the way it works with style components, so don't worry about the syntax here, is we're going to say props and we're going to map that to props dot weight. Okay, so in other words, whatever we pass in for left weight and right weight, will replace this here. So if we pass in one, it'll be flex one. If we pass in five, it'll be flex five, et cetera. Okay, so let's see how to use this. We're going to open up our app dot JS component now and add these two other props that we just created. So we're going to say left weight, and let's say that we want the left-hand side to be one third as large as the right hand side. Well, since the weight props that we've defined pretty much reflect how Flexbox works. Our left weight is going to be one and our right weight will be three. All right, so our left weight is going to be one third as wide as our right weight here. Okay, so let's take a look at our app now. And we see that the left-hand side of our split screen is now a third as wide as the right-hand side. So this would be good if we wanted to display something like a side nav of some sort. So we've seen how to add weight to the different items in our split-screen component. And the next optimization that I'm going to show you is that instead of passing in our left-hand component and right-hand component as props, it's possible with layout components to make them accept their children as children in the sense of react. Let me show you what I mean by that. Instead of passing left and right as props, okay, we're going to keep our left weight and right weight here, instead of passing our left and right components as props, we're actually going to put them inside our split-screen component as children. What that's going to look like is this, we're going to say left-hand component and right-hand component like that. And then in order to make this work with our split screen, we're going to need to open that up. And we're going to remove the left and right props here and replace that with the children prop. And then what we're going to do is down here in the body of our split screen component, we're going to say const. And since children is going to be an array in this case, containing all of the elements that we passed as children to our split-screen component, what we can do is say const left and right. And notice we're not using capital letters in this case, since these are elements and not components, we're going to say equals children. And then instead of left as a component, we're going to display left, just using the curly braces. And then for right, we're going to do the same thing. Okay, so we have left and right inside curly braces. And as we can see now, if we go back over to our app, nothing has changed except that this is generally considered to be more developer friendly, right? Being able to pass in components as children to a layout component instead of having to pass them in as props. And what this also allows us to do is for our left-hand component, if our left-hand component needs to accept props, let's say that it needs a name prop of some kind and our right-hand component takes a prop. Let's say message. Okay. And let's display those inside of there. So we'll say message and name. Okay. If we want to pass those props into our left and right-hand components now, we can just do that directly. So we can say name equals Shaun, for example, and for our right-hand component, we can say message equals hello. Okay. And we can see that that works just like we want it to, whereas if we were rendering these components inside our split-screen component and passing them through as props like before, we would have to actually pass those name and message props through our split-screen component to our left and right components respectively. So we would have to add something like this and say, right props equals blah, blah, blah. That would be an object. And the same thing with left props. And we would have to pass those directly to here. So this is just a much easier way to do it right. Saying left and right. And that allows us to pass props directly to it. And it's just considered to be a little more readable that way.

### List and list items
- All right, so the next design pattern that we're going to take a look at here with layout components is lists and list items. Now, to start off here in the exercise files, you're going to find something a little bit different. Inside the app component, we have an array of people data and an array of products data, and what we want to do is display this data inside several different kinds of lists. So I'm going to show you how to create some list and list item components that can help us do this most effectively. So, first of all, let's create a few different kinds of list items for the people and the product. We've got different data to display here, such as name, age, hair color in the people than we do with our products where we have name, price, description, et cetera. So let's start off by creating some list item components and we're actually going to create two different variations of list items for each type of resource. So let's create a folder for our people, and inside there, we're going to create a SmallPersonListItem.js and a LargePersonListItem.js. Okay, and we're going to do the same thing for our products. So let's create a product folder, we'll say products, and inside there, we're going to say SmallProductListItem.js and LargeProductListItem.js. All right, so let's go through real quick and implement each of these. First of all, we're going to start off with our small person list item, and we're not really going to add any styling to these. It's really just going to be small or large depending on the quantity of information that it displays. So for our small person list item, I'm just going to type this out real quick, we're going to say export, const, small person list item. It's going to take a person as a prop. It's going to get only the name and age from that person props, so we'll say const, name and age equals person. And then, what we're going to do is return a paragraph that says name, name, comma, age, and then we'll put in the person's age and we'll put years after that. So that's our small person list item. Now notice that this small person list item doesn't really contain any styling that would indicate it knows where it's being displayed. In other words, we could display the small person list item in a numbered list, in a very narrow list, in a very wide list, and we could use the styling in its parent component to determine how it gets displayed. We'll see that in more detail a little later on. For now, first, let's implement our large person list item. For that, I'm just going to copy and paste our small person list item into large person list item. We're going to have to change the name here and this one's going to display a little more information than the small person list item. What we're going to do is get the name, age, hair color, and hobbies, properties from the person, and we're going to display them like this. Now, we're going to display all of this inside a react fragment for the same reason that I mentioned before. We don't really want this large person list item to be determining its own styling, we want its parent component to be able to do that. So we're going to have the name displayed like this. We're just going to say name, inside an h3 tag. Under that, we're going to have a paragraph tag with the person's age, we'll say age, age years. Under that, we're going to have their hair color. So we say hair color and insert the hair color into the JSX there. And then under that, we're going to have an h3 heading that says hobbies, and we're going to display all of their hobbies here. Remember that hobbies is an array if you go back and look at the original data. So we're going to say hobbies, under that, we're going to put an unordered list and we're going to map the hobbies. So we're going to say hobbies.map and for each hobby, we're going to add a list item which we'll need a key, of course, that key is just going to be the hobby itself, and we'll insert the hobby string into that list item. So that's our large person list item and our small person list item. Now, before we go on to implementing the small product and large product list items, I want to actually create the list components themselves. So, currently, we've only been creating the actual list item components. So let's take a look at what the lists that are going to display these components are going to look like. Now, contrary to what you might be expecting where we might have a large person list and a small person list, and a large product list and a small product list, we're actually just going to have a single list component that can display all of these different list items. Let me show you how that works. Inside the source folder, we're going to create a new file and we'll call this regular list. I'll show you how to make other types of lists in a minute here. And here's what regular list is going to look like. We're going to say export, const, regular list, and this list is going to take the items that it should display. So it's taking a prop called items and it's also going to take a prop called resource name. So this is going to be either products, or people, or whatever kind of resource that this list is going to be displaying. You'll see how we use that in a second. Now, the final prop, and I'm going to just indent all of these for readability. The final prop here is going to be called item component. Now, this is going to be the actual component that we use to display each of the items in this items array prop that we're getting here. So just like we did with the left and right-hand components when we saw how to do a split screen, we're going to rename item component so that it's got a capital letter. This just keeps in with React's convention of capital letters at the beginning of their component names. And then for the body of the component, here's what it's going to look like. It's actually going to be very simple. We're just going to say return and inside some react fragments. We're going to map over all of the items and display one item component for each of them, passing it to the prop called resource name. That might sound a little confusing but here's what it looks like. We're going to say item.map. We're going to get the item and its index here. And then, we're going to display the item component and pass through the current item that we're looking at to the prop with the name of a resource name. And what that's going to look like, this might look a little confusing for you. First of all, we need to add a key, which is just going to be the index. Normally, you're not supposed to use index as keys but we're just going to do that for now. We're going to use the spread operator, so dot, dot, dot, and then we're going to spread an object with a key that's going to be that resource name prop that we had up above, and we're going to pass through item for that. So what this is going to change to, let's say that we pass in person as resource name, this is going to change to person equals item. So that's what that's going to change to. It's kind of a confusing syntax at first but it's something you'll get used to. So that is how our regular list component works. Oh and this should be items.map, not item.map. All right, so let's see how our regular list works now. Let's open up our App.js component and display two lists, one which is going to display all small person list items and one which is going to display all large person list items. All right, so down here in our app, we're going to remove this h1 tag that I put there. We're going to display our regular list, which my IDE is going to import for me automatically. And then for the props, we're going to say items equals people. Under that, we're going to say resource name equals person. Remember that this resource name is the name of the prop that our small person list item and large person list item are expecting. And finally, we're going to pass through the component that we want each of these people to be displayed inside of. So we're going to say item component equals and we're going to include one with our small person list item, which again is going to be imported automatically for me. So make sure you go up and do that if your IDE doesn't do that. And that's how the regular list works. So we have one regular list with our small person list item. Under that, let's display one with the large person list item, just to show you what's possible with that. We're going to say item component equals large person list item. And now, if we run our app, which you can again do with NPM run start, we're going to see that up here at the top, we have a list of our people with the small person list item component. And down below, we have the same list component displaying a completely different list. For all of the people, it's using the large person list item. And I just want to point out before we move on that the regular way of doing this is not to have this reusable list component. It's, instead, to create a large person list item list and a small person list item list that then display those components. So, as you can see, the way that we've done it here makes the regular list a lot more reusable. We're able to simply pass in the component that we want to be displayed as children of this list.

### Creating different list types
- Okay. So now that we've seen how to use our regular list component to display people, using two different item components, we're going to implement the same kind of components for displaying products, right? So we have our small product list item and large product list item. Let's just create some very simple components for those. So for a small product list item, here's what that's going to look like. We're going to say export const, small product list item, and that's going to take a single prop, which is going to be product, right? That's the product that it's supposed to display. And for our small item, we're just going to get the name and price of that product. We're going to say equals product. And under that, we're going to say return and simply display in an H3 heading. You can use basically whatever element you want here, but I'm going to use an H3 heading. We're going to say name and price with a dash in between them, okay. And again, what this is going to allow us to do is have the parent component, essentially, whatever kind of list is displaying this item, determine the overall styling instead of us, you know, putting some kind of styled div as a wrapper. So that's a small product list item, for the large product list item, we're just going to add a little bit more data. So we'll say export const, large product list item, equals, and we have the product as the prop. And we're going to get the name, price, description, and rating from that product prop. So we're going to say name, price, description, rating equals product. And we're going to display all of those inside a fairly simple UI. We're just going to wrap all of this inside of react fragment, and we're going to have an H3 heading with the products name, like that, under that we're going to have the price of the product. So we're just going to display price inside a paragraph tag. Under that, we're going to have an H3 heading that says description. All right, so under here will be where we display the description now. We're going to say paragraph description. And finally under that, we're going to say average rating and display the products rating, okay. So that's the large product list item, before we display these however, I want to show you how to create a different type of list. So earlier we created this regular list, which simply takes some items, a resource name, and a given component that we want to display , maps over the items and passes the correct props to whatever component we give it. Now, if we wanted to simply display our large product, small product list item, et cetera. Inside this regular list, all we would have to do, is change this regular list, change items to products, change the resource name to product and change the item component to either small product list item, or large product list item. All right, and it would be as simple as that, we don't have to create any extra components or anything. Now, what if we wanted to display, as I've said before, a different type of list. What if we wanted to display a list that automatically numbered all of its items, for example? Well, the way we would do that is by creating a similar component to our regular list that we created before. All right, we're going to create a new file and we'll call it numberedlist.js, okay. And the numbered lists is going to be very similar to the regular list. The main difference is that it's going to automatically display numbers, along with its items. All right, so it's going to take items, resource name, and item component. And then instead of simply displaying the item component inside this map here, we're going to wrap it in react fragments and above this here, we're going to have H3 and we're going to display the number of each item that we're displaying. Now, since I is the index, we're actually going to display I plus one, so that it starts at one and goes one, two, three, four, five, et cetera, okay. So now all we need to do, if we want to display, let's say the large person list item with a numbered list, we literally just change this to numbered list. And it's not importing that for me because I forgot to change the name of it inside of here. So we'll change that to numbered list. Let's try typing that again. There we go, and it imported it for me now. Okay, so if we want to display our large person list item with the numbered list, all we have to do is say numbered list instead of regular list. And if we want to display our large product list item with the numbered list, all we have to do is take that change people to products, change resource name, to product, and change large person list item to large product list item, which will also be important automatically. So if we go back now, we see that the numbered list worked just like we wanted it to. Now, I didn't add much styling here. If you want to do that yourself, feel free to go ahead and do that. And we see that the numbered list also worked with each of our product list items. So what you can see here, the point of all of this is that by creating just six different components, right. Our large and small person and product list items and our regular list and numbered list components. We were able to create a lot of different combinations, right? We were able to create a total of eight different combinations. If you assume regular and numbered for each of these small person list item, large person list item, et cetera. And that might not seem like a huge savings at first, but as your apps get larger and larger, this can really end up saving you a lot of time.

### Modal components
- All right, so we've seen how to do split screen components. We've seen how to do list components and list items. The last layout component that we're going to take a look at here is modals. Now, modals are obviously an incredibly popular thing to see in web applications. So let's see how to create them as another layout design pattern. The first thing we're going to do is create a new file here, which we'll call modal.js. And this is going to contain all of the code for our modal, obviously. Now, before I show you how to implement this component, I just want to say that when most people go to add modals to the react application, almost always the first thing they do is install, react modal, or a similar package like that, but that's really not necessary. And I'll show you why it's actually quite simple to implement your own. What we're going to do is we're going to say import use state from react. And we're also going to import styled from styled components. We're going to be using this to add the actual modal styling. And then our basic modal component is going to look something like this. We'll say export, const, modal, and we're going to basically get the children. This is going to be very similar to what we did with our split screen component. We're not going to pass in the modal contents as a prop. In other words, we're just going to display them, sort of like this. We're going to say modal, and then inside there some component. Inside, say the app component, okay. So this children prop allows us to do that. Now for the body of our component, we're going to have a state variable here called should show and set should show. And we're going to set that to false initially. So initially the modal is going to be hidden, okay. And then for the actual structure of the model, we're going to go up and create two different styled components. The first one is going to be called modal background, and that's going to be a styled div. So we'll say styled.div, and with back ticks, and we'll come back to the styles for that in just a minute. And then we're going to have another style component called modal body. So we'll say const modal body equals styled.div, and we'll come back and do both of those in just a second. First, I just want to show you what the JSX here is going to look like, with those styled components. We're going to basically just have the modal background here. Inside that is going to be the modal body and inside the modal body is going to be the actual children that we passed to this modal component. Now we're going to add a few more things. The first thing is that we only want the modal background, modal body, et cetera, to show when should show is true. So what that's going to look like, we're just going to use short circuit evaluation here to do that. We're going to say, should show and, and then with parentheses, we'll say modal background, modal body, et cetera. So in other words, all of these things are only going to show, if should show is true. And in order to actually get the modal to show up in the first place, we're going to put a button who's on click property, basically sets this should show state to true. So we're going to have a function here that says set should show to true. And the button is going to say something like show modal, okay. And in order to make react happy, we're going to have to wrap all of this in react fragments. This isn't so much for styling, mostly this button here that shows the modal is just to get the modal to show up in the first place. Later on in the course, we're going to see a better approach on how to do this, okay. Now, a few more things before our model will work like we want it to. The first thing is that when a user clicks on our modal background, we'll want it to hide the modal, right? This is pretty typical functionality in most modals. So we're going to say on click for that equals, and this is just going to say, set should show to false. And then inside the body of the modal itself, we're going to have another button that will actually allow the user to hide it. Normally this would just be an X button or something up in the top right-hand corner. We're just going to use a regular button for now that says hide modal. And for the on click method of that, we're going to set should show to false. So on click, set should show false, okay. And lastly, for our modal body here, we need to add an onclick event. And basically what this is going to do is call event.stop propagation. And basically the reason that we have to do this is whenever the user clicks on one of the children inside our component, we don't want that click event bubbling up and closing the modal, right? If we left this off, that's exactly what would happen whenever the user clicked on anything inside the modal, it would close the modal. So that's what our model needs to look like. Let's now add some of our styles. And in fact, the styles are not super complicated, but if you just want to copy and paste those from the end state of the exercise files, I would highly recommend that. In fact, that's what I'm going to do here, just to save us a little bit of time. So that's what the modal background is going to look like. It's just going to be a semi-transparent, dark gray background that covers the rest of the page. And for our modal body here, I'm just going to copy and paste those as well. It's basically just going to have a white background. It's going to take up 50% of the screen, have a little bit of margin, padding, et cetera. So that's our modal component, in order to demonstrate what this will actually look like, let's open up our app.JS. And just to show you, remember earlier, when we created our small person list item, large person list item, et cetera. I said that making those in such a way that they didn't contain their own styles would make them much more flexible in the future. Now I'm going to demonstrate how that's true by inserting one of those list items. Let's pick the large product list item, for example, and displaying that inside our new modal component, okay. So let's display our model here and inside that modal, we're going to display our large product list item. So we'll say large product list item. And for the prop here, that's just going to be product and we'll pass the first element of our product array up at the top, okay. So if we make sure that our app is running and head over here, we're going to click on show model, and sure enough, we'll see that the details of that product are now inside our modal, right? And you can click either on the background or on this hide modal button and it will hide the modal for us. All right, and obviously if we were going to use this large product list item for other things, besides list items, we might want to rename it to something like large product details, right? And that would make more sense. And that would allow us to basically display that now either in a list or in a modal, which is kind of the strong suit of layout components.


### What are container compoent
- Okay, so the next React design pattern that we're going to take a look at is something called Container Components. So what are container components exactly? Well, container components are basically React components that take care of all of the data loading and other data management for their child components. In order to show you what I mean with this, let's imagine that we have the setup that you see here, a container component with several child components inside of it. Well, normally what you would do, if you're like most beginning to Intermediate React Developers is you would just have each of those child components load their own data and then display it, right? So up where it says low data, you probably have a useState hook and a useEffect hook and use something like Axios or Fetch to get data from a server. Now, the problem with this is that a lot of the time we need our child components to be able to share that logic. And the way that container components solve that problem is by splitting that logic out into its own component, which is the container and the container then takes care of loading that data and passes it automatically to the children components. We're going to see how exactly this works very soon. So then the main idea of container components is this, just like how with layout components, we didn't want our child components to know or care what layout they were part of. With container components, we don't want our components to know where their data is coming from or how to manage it. We just want our components to be dumb and take some props and display whatever they need to display.

### Server Instructions
- Now that we've learned a little bit about what container components are exactly and their main goal, what we're going to do is take a look at a few examples that demonstrate how container components are used. The way we're going to go about this is we're going to start off with a fairly simple and not very re-usable example. Over the course of the next few videos, we're going to improve it and slowly make it more and more re-usable until we reach what I would consider a good stopping point. The first thing you're going to want to do here is get the starting state of the exercise files because it's different than the way we left it after we talked about layout components. Let's just discuss a few of the things that it contains. The first thing is this app component. There's not really anything in here. We've basically cleaned it all out of the code that we wrote before. Then we also have these UserInfo and ProductInfo components, which are basically just slightly-modified versions of the large person list item and large product list item components that we wrote previously. The main difference is that with our large person list item component, we've just changed the word person to user, because that's a more realistic scenario for most applications, is users. We have our UserInfo and ProductInfo components, which take a user and product prop separately. What we want to have these components do is display some data that we load from a server. That's the last file I wanted to talk about, is this server.js file that you'll find in the root directory of the exercise files. Basically, this is just a simple express server that will send back some data to our components. This is just to simulate a real-world, full-stack React app. We have the current user here. We have an array of all of the users on our site. There's only three of them as you can see, and we have an array of products. Then below that, we just have a few different endpoints that are going to send that data that we've looked at before back to our client side. We have a current user route for getting the information for the current user. We have a users ID route. Basically, this allows us to get an individual user by their ID. We have a post users ID, which allows us to modify users. We have a get all users endpoint, we have a get product by ID endpoint, and we have a get all products endpoint. Don't worry too much if you're not super familiar with backend development. You don't need to know all about express servers. I'll explain when we actually make requests to this server what each request is supposed to be doing. I'm going to close this server.js file since we won't be making any changes to it in this course. We're just going to use that as, basically, a mock that we're going to send requests to from our React application. But one thing you are going to want to do is know how to run that server. The way you're going to do that is by typing node and then the path to that file, which is just going to be server.js, provided that you're in the root directory. You should see that it says server is listening on port 8080. Just as a side note, you do need to run npm install in the exercise files directory before this will work.

### CurrentUserLoad component
- Okay, so you're going to want to leave the server running and open up a new terminal or just another tab in your existing terminal like I'm doing. And inside here, we're just going to run our react app by saying NPM run start. Oh, and one last thing I wanted to point out is that in order to make our front end and backend communicate with each other, I've also added a proxy to the package.json file. If you don't know what this is, don't worry about it for now. Okay, so we have our react app running. Obviously, there's not really very much going on here. So what we're going to do is, we're going to create a container component that will take care of loading the current user data, that's where we're going to start off here, and passing it to our user info component. So let's start off by creating that container component. Inside our source folder here, we're going to say new file, and we'll call this component CurrentUserLoader.js, because, again, it's going to take care of loading the data of our current user from the server. And here's what this component is going to look like. We're going to start off by saying export const current user loader. And the only prop that we're really going to care about for this container component is going to be the children prop. This is, again, all of the components that are inside the opening and closing tags of our current user loader component when we render it. And inside here, what we're going to do is have the basic react loading logic. So, anyone who's worked with full stack react before, or who's written a react app that interfaces with a third-party API will know that the way this is generally done is by using the use state and use effect hooks, which we import from react. And we're going to start off by saying const user set user equals use state, and the initial value for our user is going to be null. So basically, the user state is going to be null while we're loading our data. Okay. And then, we're going to actually load our data from the server by using this use effect hook. And we need to pass an empty array as a second argument to make sure that it only executes when it's first rendered. And inside here, we're going to create an async function, and this is just a shorthand version here for writing an anonymous async function. So inside here, we're going to say const response, and there are several different libraries or APIs that we can use to load data from a server. My personal preference is to use the Axios library. So that's what we're going to do here. And we need to install that first by saying NPM install Axios. If you haven't used Axios before, it's super simple to use, as you'll see. And we'll run our react app again. Okay. So now, we're going to import Axios from Axios and use that here to get a response from the server. So we're going to say await axios.get, and the end point that we're going to be loading our current user from, as I showed you a little earlier, is going to be /current-user. Okay. So now, this response is going to contain the data for the current user, which we can get by saying const current user equals response.data, and then saying set user current user. We could just shorten this as well by saying set user response.data. And now that we have our user data loaded from the server, all we have to do is pass this user state from our current user loader component down to all of its children components, which we're getting in the prop here. So, just to clarify what I mean by this, let's import our current user loader component. And we're also going to import our user info component, from user info. Okay, and what we want to do here is say current user loader, and inside the opening and closing tags of this component, we're going to have our user info component. And what is automatically going to happen, even though there's no props that we can see here, is our current user loader component is going to pass a user prop to our user info component, just because user info is one of its children. So here's how we make react do that. We're going to say return inside our current user loader component, and we're going to have just an opening and closing react fragment here. The syntax that we're about to use just requires us to do that. And then what we're going to do is, inside curly braces, we're going to say react.children.map children, and for each child that is inside this current user loader component, what we're going to do is say if that child is a valid react element, this is just for safety here, we're going to say, if react.isValidElement child, then we're going to return react.clone element child, and the second argument to this function allows us to specify extra props that we pass in to that child component. So in our case here, we're passing the user state that we have up here into that user prop of that child component. Otherwise, if it's not a valid react element, we're just going to return that child. And of course, we have to import react up at the top by saying import react. And that's all there is to it. So our current user loader component should work now, and this code that we wrote here should work as well. So let's give it a try. Let's open up our component and hit refresh. And what we're going to see is that we're getting this error that says cannot destructure property name of user, as it is null. The reason that this is currently happening is that inside our user info component, user is initially null while that data is loading. So there's a few ways that we can fix this. One way would simply be to provide a default value for user. Another way would be to check if user exists before returning this JSX, so we could say return user. And if the user exists, return all that. Otherwise, we could return loading. And this is actually what I'm going to leave it as, since this will work perfectly fine and it will also tell us when this current user is loading. So let's go back and refresh our application now. Ah, and we also need to add a default value here, so we can just say that. And that should fix it. Okay, so we see that now it's loaded John Doe from our server and it's displayed the information for this user inside the user info component that we had. And you can also see if you refresh that it very briefly shows that little loading paragraph tag.

### UserLoader component
- All right, so now that we've implemented this CurrentUserLoader, it's time for me to point out a few things that aren't quite right about it, or aren't quite ideal, at any rate. The main thing that's not ideal about our CurrentUserLoader is that it's very restricted in what it's capable of doing. Essentially, all this CurrentUserLoader does is load a single user and passes it to its children, and that single user is this currentUser that we're loading from the server. So what we're going to do, in this video, is modify our CurrentUserLoader component so that instead of just loading the currentUser, it's able to load any user we want by their ID. In fact, what we're going to do instead of modifying the CurrentUserLoader, we're just going to create a new file which we'll call UserLoader.js. And we're going to start off by just copying and pasting all of the code over from CurrentUserLoader into UserLoader. And, of course, changing the name of the component to UserLoader instead of CurrentUserLoader. Okay, now the main thing that we're going to change, about this UserLoader, is the URL that it's going to send a request to, right. When I showed you the server, we saw that the currentUser endpoint sent back just the data for the currentUser. And, just to show you that, let me open up the server and we can see that this currentUser, here, is what gets sent back in our currentUser endpoint, right, we're just sending back that currentUser object. So what we're going to do instead is send a request to this users/:id route, which allows us to get any user by their ID. So here's what that's going to look like. We're going to replace the endpoint that we're sending a request, here, to. We're going to use back ticks because we want to insert a value into this string. And we're going to say /users/, and then we want to insert the ID of the user that we want to load. Now the main problem, here, in this UserLoader component, is that we don't know what user ID we want. So what we're going to do is have the parent component, that's probably going to be the app component in our case, pass in the user ID as a prop. So we're going to have userId be a prop, along with children, and we're just going to insert that into the URL here. All right, and now that we've done that, we need to put userId into the array of useEffect, so that useEffect will run whenever this changes, although, in reality, it shouldn't. And then we're, actually, going to open up our server.js file. I may have mentioned earlier that we wouldn't be changing it, but that's not entirely true. And what we're going to do is add IDs, to these three users in our array, in order for everything to work. So we're just going to add some very simple IDs. The first one should be 123, the second one should be 234, and the third one we'll make 345, okay. And you can add one to the currentUser as well, if you want, we'll just make that 123, just like the user in this array, here, with the same name. And we're probably going to want to do the same thing for products, so we'll say products, we'll make these IDs four digits. So we'll have 1234, id: 2345, id: 3456, and that should make everything work just like we want it to. Okay, so now that we have this UserLoader component, which provides us with a little bit more flexibility than our CurrentUserLoader component, let's see how we can use it inside app.js. Okay, so we're going to import our UserLoader from UserLoader and we're going to replace CurrentUserLoader with UserLoader, and we're going to pass the userId as a prop to it. So we're going to say UserLoader userId, just to check, let's do 234. Okay, and we're going to change this closing tag to UserLoader as well. And one last thing we need to do, before this will actually work, I realized I didn't do it before, is since we've made changes to our server, we need to actually restart it in order for those IDs to take effect. Okay, so now we should be good to go. Let's head over and check in the browser. And we should see that Brenda Smith is, indeed, loaded from the server, right, because they are user 234. So what we can, actually, do with this UserLoader is we can reuse it several times over, right. And, of course, we're going to need to wrap this in React fragments like this. But what we can do is say we want user 123, we want user 234, and we want user 345, and each of these respective container components will load only that user with that ID and pass that different data to the same component, which will give us all of our users rendered in a, sort of, list here. If we wanted to, we could even say something like const userIds equals 123, 234, 345, and then just map these IDs and have UserLoader pass that ID and have UserInfo inside of it. I'm not going to do that here, but that would be something that you could definitely do.

### ResourceLoader component
- All right, so we refactored our current user loader into a more generic user loader that allows us to load different users instead of just the current user from our server. And this is a big step up from what we had before, but we can still take it a little further. What we're going to do, is instead of having a container component that loads a specific type of resource, we're going to have a generic component that allows us to load any type of resource from the server. So, here's what this is going to look like. We're going to start off by creating a new component and we're going to call this component resource loader, and we're actually going to copy some of our user loader code into here. Okay, so we're going to copy that, paste it in here, change the name of our component to resource loader, and there we go. So the first thing we're going to do with our resource loader component is instead of having a user ID as part of the props, we're going to have two other props. One is going to be the resource URL that we want to load data from, okay? So that would be slash users slash user ID. We're going to have the parent component pass that in instead. And the second one is going to be the resource name. This is going to be sort of similar to what we saw earlier in the course when we created our different list item components, okay? So we have a resource URL, resource name and children, and that's all we need for now. The next thing we're going to do, is change the name of our state here. Since it's no longer dealing just with users, we're just going to call the state state and set state. And instead of having the URL hard-coded here inside axios.get, we're going to just change that to axios.get resource URL, okay? And we're going to say set state to reflect that name change. And inside this use effect array, we're going to have to pass in resource URL just in case that changes, so our component will be able to reload the data, all right? And then we're going to keep this react.children.map thing, pretty much the same, except instead of just passing through a user prompts since user no longer exists, we're going to pass through a prop with the name equal to the resource name that we passed in. So if resource name is product, for example, this will be product, right? We're just going to specify resource name, and then the current value of the state. And that's pretty much all we need to change. So let's see how this is used now, by going back to our app component. And by the way, make sure that you're running both the server by running node server.js, and the react app by running NPM run start. And what we should be able to do now, is import our new resource loader component. We're going to say import resource loader from resource loader, and instead of having a user loader for each of these, I'm just going to replace all of these. Let's try loading some different types of resources. So for the first one, obviously just to see how it works, we can say resource loader and pass in the resource URL, which we can set to slash users slash one, two, three, for example. And the resource name, which would be user. And inside here, we have user info, okay? So this right here will have almost exactly the same functionality as we had before with our user loader, right? And we can see that that works just like before. However, it's a lot more flexible because now what we can do, is if we want to load some other server resource, like our products, we can do so by saying, resource loader, and then for the resource URL, we specify the URL of the products by saying slash product slash, and then the idea of one of our products, one, two, three, four is a good one here. And then the resource name is going to be product instead of user, okay? And then inside here, we can put our product info component, which we have to import. Up here, we're going to say import product info from product info. And if we go back to our app, it looks like we're going to have to make the same change to our product info component as we did to our user info component earlier, we're going to need to open that up. We're going to need to add a default value for product here, and we're going to want to check if the product exists before displaying it. So we're going to say product, or if it doesn't exist, we're going to display a loading message here, okay? So if we go back here now, we see that the resource loader component is working with both the user info component and with the product info components. So essentially we can use this container component resource loader to load any and all of the resources for their child components. And notice that this also saves us from having to copy and paste this kind of code between all the components that need it, right? That's one thing that I see quite often in react applications is just the same state and use effect over and over again, inside different components with only slightly different data needs. So as you can see here, we've pretty much solved that problem by making a reusable container component.

### DataSource component
- So we've seen how to make the concept of container components much more generic by creating this ResourceLoader component. That basically can load any resource we want from the server and automatically pass it to its child components, right? We saw how to have it load both users and products. And of course, it could load pretty much any other server resource that we wanted as well. Now, honestly, I would consider this a good stopping point for most applications. But just for fun, we're going to see how we might take this concept one step further and have a component that doesn't even know where its data is coming from. So to show you what I mean by this, I'm going to create a new file inside our source directory. And we're going to call this file DataSource.js. And this is going to be basically a container component, just like ResourceLoader. Except instead of starting off with the idea that we're going to be loading some resource from a URL on the server, this data source component, isn't going to know exactly where its data is coming from. So here's what this is going to look like. Instead of having this resource URL prop, we're going to have a prop called getDataFunction. And this is basically just going to be a function that will return whatever data the child components of our data source need. And we're going to leave this resource name thing here since we'll be needing it for the prop down below. But basically, the only change that we need to make here is instead of saying axios.get and passing a resource URL, And then what we're going to do is instead of specifically using Axios here to load data from our server, we're going to do something a little bit more generic. We're going to say const data equals await getDataFunction. And then we're just going to say setState data, okay? And we don't need this resource URL thing anymore, but we do need the getDataFunction just on the off chance that it changes. Although, it really has no reason to. So that's the only change that we need to make to our data source component. Now, let's see how this thing is actually going to work when we use it, okay? So what this is going to look like, let's start off by importing it. We're going to say import DataSource from DataSource. And we're going to replace our resource loaders here with a data source. And I'm going to start off by showing you how to replicate the functionality of our ResourceLoader using DataSource. Basically, what this is going to look like is we're just going to say DataSource and we're going to have our getDataFunction. And then for this getDataFunction, here's what that's going to look like. We're basically just going to have the code inside here that used to be inside our ResourceLoader, right? So we're going to say await axios.get. And we're going to return this response .data since our data source is basically just expecting this getDataFunction to return whatever data we eventually want to pass to its child component. So here's what that'll look like. We're going to start off, and this is going to be an asynchronous function by the way. We're going to say async. And we're going to say const response equals axios.get. For the URL, we'll just say users/123. And this needs an await as well. And then under that, we're just going to say return response.data, okay? So that's our getDataFunction. We also need the resource name, which in this case is going to be user. And then for the children, we're just going to have our user info component like that. And we also need to import Axios up at the top. So import Axios from Axios. And we should see now that this DataSource works just like our ResourceLoader did and our UserLoader did before it. And it basically does whatever we tell it in the getDataFunction. And passes that as a prop to all of the child components inside of it. So in the real world, here's how we might make this getDataFunction thing more simple. Since obviously, we don't want to have to pass in this big anonymous function every time we want to load data, right? So what we could do is just cut this out, create a function for it somewhere, right? We might say getServerData. And this would, of course, be an async function. We could specify the URL we wanted by saying URL and returning that function there like that. And then how we would actually use this thing is we would simply pass getServerData with the URL as the getDataFunction prop. And that would turn into this async function here with the corresponding URL. And we see that that still works.

### Loading data from localStorage
- So now that we've seen how to recreate the functionality that we already had with resource loader, let me show you how data source can go another step further. One thing that we might want to do is get some sort of message or something that's stored in our local storage instead of loading that data from a server. So what we could do in that case is we would define a corresponding function here to get server data. And we would call that something like get local storage data. Okay, and what this would be is a function that would take the key where something is stored in local storage in the user's browser. Return a function, and this doesn't need to be asynchronous since local storage isn't asynchronous. And we would just say return local storage dot, get item key. And then in order to use that, let's first of all, go and add something into our local storage. To do that you just have to open up the inspector window, go to application, and we're going to add an item by just double-clicking right under key here. And we'll add a message key. And the value for that will be something like hello from local storage. And it actually doesn't need those quotation marks since everything is by default, a string in local storage. So now what we can do just for the sake of example, I'm going to define a text component here, which takes a prop called message. That's what we'll be loading from local storage. And it's just going to return h1 with that message inside of it. You'll see how this comes together in just a minute. We're going to say data source, and what we're going to do now for the get data function, we're going to pass in, get local storage data. The key for that is going to be message. And the resource name here is going to be message as well. And then inside there, we'll have our text component that we just created. And this text component is automatically going to receive the contents of that piece of local storage in its prop called message. So what we're going to see if we go back here, we're going to see hello from local storage, which is our text component, getting its data from local storage via our data source component.

### Controlled vs. uncontrolled components
- [Instructor] All right, so the next React design pattern that we're going to take a look at is controlled and uncontrolled components. Now, this is a very, very common pattern to find in React, both of these, both controlled and uncontrolled components, so let's take a look at what both of these mean. First let's start off by defining uncontrolled components. Uncontrolled components are basically React components where the component itself keeps track of all its own internal state and really the only time we get data out of that component is when some event occurs. So this would be in the case of, let's say, a form when the user hits the Submit button. In an uncontrolled form, that would be the only time we actually know what values the inputs of that form contain. Controlled components, on the other hand, are basically components where their parent is the one that takes care of keeping track of the state and that state is then usually passed through to a controlled component as a prop of some sort. So those are just the basic definitions. Let's take a look at what this might look like in code. For uncontrolled components, more often than not, the component itself again is going to be the one that keeps track of its own state. So what this is going to look like up here at the top, we see that this component has its own useState hook and the only prop that it's getting past is this onSubmit prop, which the parent component would pass a function to to actually get the values of that component's state when the submit event is triggered. With controlled components, on the other hand, we see that our component no longer has that useState hook. In other words, the state of that component is passed through as props. And, of course, there's other kinds of functions that this component is going to use, as well. You'll see how this works very shortly when we take a look at some examples of this. So one question that comes up when we talk about uncontrolled and controlled components is which one do we generally prefer? Well, more often than not, we're going to prefer controlled components and there are several reasons for this. The main reason is that it just makes our components more reusable and it also makes them a lot easier to test since we can just set up a component with the exact state we want, instead of having to create the component manually, make some changes, and then trigger some event to find out what's going on inside of it. So in other words, controlled components are just easier to test, they're more reusable, we more often than not will prefer them.

### Uncontrolled forms
- [Instructor] All right, so now that we know some of the basic theory behind controlled and uncontrolled components, let's take a look at some examples of what they're going going to look like in code. Now we're going to start off by taking a look at forms since controlled and uncontrolled forms are the most commonly used types of components in React. So let's start off here by creating an uncontrolled form and we'll see exactly how that works. And before you get started here, make sure that you copy the starting state of the exercise files since it's a little different than how we left it off in the previous chapter. And you're also going to want to make sure you run NPM install before running your code. And just like before, we're going to run this app by running NPM run, start in the terminal. Okay, so we're going to start off by creating an uncontrolled form components. So let's add a new file to our project called uncontrolled form dot JS. And here's what an uncontrolled form in React is going to look like. Basically, this uncontrolled form is going to defer most of its logic to the actual DOM elements underneath. Let me show you what I mean, we're going to start off here by saying import React from 'react'. Then we're going to export our component here by saying export const uncontrolled form. And the JSX for this form is going to look like this. We're going to have a form inside that form. We're going to have several inputs. So let's just say that this form is collecting information about a user, right? So we'll have input, we'll have name equals name, type equals text, and we'll have a place holder here that says name, okay. And we're going to have several more inputs of different types. The one underneath that is going to be an age input, the type is going to be number. And the placeholder here will be age. Under that we're going to have hair color for the name. The type will be text, and the place holder will be hair color. And finally, we're going to have an input which is going to be the submit button. So we're going to say, we're going to remove the name. We're going to say type equals submit and value here. This is just going to be the text of this button is going to be submit, okay. So here is where the uncontrolledness of this form comes in. Basically, what we're going to do is our form is going to handle the on submit event. And for this, we're going to add a handle, submit function up here in our component. We'll say const handle submit. And inside here is the only place that we're really going to do any kind of logic with the values from our form. Now in order to actually get those values from our form, what we need to do is create some React Refs. And the way we do that is by saying something like const name input equals React dot create Ref. And then what we do is we pass this name input Ref as a prop to our input. So we would say something like ref equals name, input, and then we do the same thing for the other inputs that we need to get the value of. So we'll have an age input ref, and we'll have a hair color input ref, and we'll pass those as props to these other inputs. We'll say ref equals age input and ref equals hair color input. Okay, and then when this form is actually submitted, when the user clicks this submit button, what we do is we simply get the current values of those inputs by saying something like this, I'm just going to log it out to the console for now, we'll say console dot log name, input dot current dot value. And then we do the same thing for our other inputs as well. So we might have age input dot current dot value, and hair color input dot current dot value. And then we would want to say e dot prevent default because the default behavior of a form when we submit it is to refresh the page. And we also need to add e as an argument here, which is this the event that's occurring in this on submit handler. Okay, so that's our uncontrolled form. The way that we're going to use that in our higher component here would be to do something like this. We would say import uncontrolled form from uncontrolled form. And we would just display it in here like this, and let's go see what that will look like. We're just going to enter something in here and click submit. And if we open up our console here, oops, it looks like I misspelled on submit in our uncontrolled form here. There we go. Let's try that again and submit. And we'll see that sure enough, it logs out the values of those inputs. Now again, what makes this uncontrolled is that this component isn't really caring about what the values of each of these inputs is until some event occurs, right? Basically each of these inputs is just handling its own state until we submit the form. At which point we get all of the values.

### Controlled forms
- [Instructor] Okay, so now that we've seen what an uncontrolled form looks like, let's take a look at what a controlled form is going to look like and how it's different. So we're going to start off by creating a new file here, which we'll call ControlledForm.js. And our component is going to look like this. We're going to say export const ControlledForm equals, and then we'll have the body of our component. And the main difference with our controlled form is going to be that we're going to track the values of each of our forms inputs using a useState hook. So what this is going to look like, we're going to start off by importing the useState hook up here, import useState from react. And then inside our ControlledForm component, we're going to create state variables for all of the inputs that we're going to be inserting into our form. So we're going to say const name setName equals useState. And the starting value is going to be an empty string, const age, setAge equals useState. We'll just leave the initial value empty for that. And const hairColor, setHairColor equals useState, and the initial value for that will be an empty string. So now that we have these three different state variables, we're going to create our form in JSX. So we've got our form, inside that we're going to have a few inputs. So we're going to say input, the name for this first one will be name, the type will be text, the placeholder is going to be named just like we had before. Now, where this starts to differ from our uncontrolled form that we had before is we're going to actually pass in the value to each of these inputs. So the value for each of these inputs, that is the text that each input currently contains is going to be equal to the current value of the corresponding state variable. So the value of our name input is going to be equal to the name state. And the other thing that's different is that each of these inputs is going to have an onChange handler that will basically take care of updating each of these state variables whenever the user starts to change the value inside the text input, say by typing. So what this is going to look like is we're going to say e, that's the event by the way. And we're going to say setName to e.target.value. Basically what that's doing is it's setting the name state to the target value of this text input, basically whatever the user is trying to type in, or paste, or whatever. And that is what our inputs are going to look like in controlled forms. Just to make this a little more readable, I'm going to put each of these props on its separate line. Just a little easier to read there since we don't have the horizontal scroll. So that's our name input, let's define our age and hairColor inputs as well. This one here is going to have name equal to age. The type is going to be number. The placeholder is going to be Age. The value is going to be age. And for onChange we're going to say setAge to e.target.value. And since the value that we get from text inputs is always going be a string even when it's of type number, we're going to say number and explicitly convert that target value to a number. And finally, with our hairColor input, we're going to say name equals hairColor, type equals text, placeholder equals hairColor, and value equals our hairColor state. And for onChange, we're going to say setHairColor to e.target.value. And that's all we need to do. So again, what each of these inputs is doing, what our controlled form is doing that is, is it's creating a two-way binding between the value of each of these inputs and the value of each of these state variables. And I'll show you in just a second what that allows us to do. The last thing that our form needs, though before we do that, is just a button here that will say Submit. And generally when we're not relying on the onSubmit event, we just have a regular button inside of our form instead of a input of type submit. So that's what a controlled form looks like, but what are the benefits of this kind of thing? Well, the main benefit, the one that I use most often anyway, is that controlled forms allow us to do things like, form validation while the user is typing. In other words, before the user has tried to submit the form, we can give them feedback about the values that they've entered in. Let me show you how that's going to work. So, first of all, we're going to import the useEffect hook from react. And what we're going to do is we're going to have this useEffect hook listen for changes in any one of these state variables. The way we're going to do that is by saying useEffect. And we have our function here. And the second argument is going to be an array of values that we want to listen for. So we'll just start off with name. Basically what this means is that this useEffect hook here will fire whenever the value of name changes. So here's what we can do with that. Let's say that we want to show the user an error if their name is, let's say less than two characters long. Well, the way we would do that is inside this useEffect hook, we would say if name.length is less than two, then what we could do is say console.log, and just tell the user, Name must be two or more characters. Now, obviously showing errors in the browser console isn't what we would want to do in most cases, but this is just for example. So let's take a look at our application now and what we're going to see, oh, first we need to actually display the ControlledForm inside our app component. So let's import that. Say import ControlledForm from ControlledForm And we'll display our ControlledForm like that. And let's just refresh this and remove so that we're at localhost:3000. And let's start typing something into the name. So we can see that when the name is one character, we get this error printed out that says, name must be two or more characters. And then as we continue typing, it gets rid of that. Now, the way you would actually use this in a React app would look something like this. It'd probably have a state that would be something like, nameInputError, setNameInputError equals useState. And it would just be an empty string at first. And you could display that inside the form if you wanted to. So you could say nameInputError, and, and then you might just have a paragraph tag that displays it. So you would say nameInputError. And then if name.length is less than two, what you would do is you would say setNameInputError, and you could just display some kind of message like, Name must be two or more characters. And then you would add an else block to this if statement saying setNameInputError to nothing. So in other words, if the name is two or more characters, we don't want to show an error. And what this would look like if we go back to our application, is we see that immediately it's displaying name must be two or more characters. As soon as we input something that's valid, it gets rid of that error. So as you can see, controlled forms are really just much better for doing interactive stuff like that.

### Controlled modals
- [Instructor] Okay, the next example of uncontrolled and controlled components that we're going to take a look at is modals. Now, in this case, we actually already have an uncontrolled version of a modal component from earlier in the course when we created this modal. Now, this modal is uncontrolled. And the reason we say that is that the modal itself is the one that's controlling whether or not it's shown, and it also controls when it's hidden. And there's a few problems with this setup. The main problem is that none of the other components, right? For example, if we want to display this in our App component, which we can do by importing it here and displaying it here, refresh it there and we can take a look at it, okay? The problem is that the parent component really has no control over what this modal is doing. So let's say that we had another button on our page that we wanted to display the modal, right? Let's say that we had a button under here that says Show Modal or something like that. Well, there's really no way for this button now to make this modal display itself because, again, the modal is the only one that has control over its state. So what we're going to do here is take a look at how to transform this modal into a controlled modal that the parent component can actually manipulate in the way that it needs to. So, first of all, let's rename this Modal here to UncontrolledModal. We're going to rename it here, UncontrolledModal. Okay? And, of course, we'll change the name inside the file to UncontrolledModal. Change the import here to UncontrolledModal as well. And it looks like it already changed the file path for me. Okay, so let's create another modal called ControlledModal, right. We'll just put that in here, ControlledModal.js. We're going to copy and paste all of the code from our UncontrolledModal into there and make a few changes to it. So let's change the name first of all. Let's say ControlledModal. All right, and the main change we're going to make here is instead of having our ControlledModal use this useState hook to determine whether or not it should show, we're going to pass that in as a prop, so we'll say shouldShow, and remove the useState hook. Okay? So we don't even need to import it anymore. And we're also going to pass in a prop called onClose, right? Any of you who have used the react-modal library in the past maybe used to seeing this as onRequestClose, right? And that's probably a more accurate description of what this is doing, as you'll see. So, basically, what this is going to do is shouldShow is going to be a boolean that's passed in from the parent component. So the parent component is going to control whether the ControlledModal is shown or not, hence the name Controlled. And this onRequestClose function is going to allow the modal itself to request that the parent component stop showing it. Now, that will obviously only be one way that the parent component can stop showing it. The parent component will have the ultimate say over whether the modal shows up or not. Okay, so let's change all of these setShouldShow true things to just onRequestClose, right? They don't need to take any arguments or anything, as you'll see. I'm going to say onRequestClose and onRequestClose. Oh, and we don't even need this button anymore really since the parent component will be the one that displays the button that will actually show the modal. So let's remove that button there. And we can also shorten this up a little bit so that we just say return. If shouldShow is true, we're going to show all of that JSX. Otherwise, what we're going to do is simply return null from this component. There we go. So let's see what using this ControlledModal is going to look like now. Well, first of all, our App component is going to have to have a state that keeps track of whether the ControlledModal should be shown or not. So we'll import the useState hook here from react. We're going to display our ControlledModal here, which we'll have to import up at the top. We'll say import ControlledModal from ./ControlledModal. And then what we're going to do is define a prop up here that says something like shouldShowModal and setShouldShowModal equals useState, and we'll set that state to false, okay? And what we can do now is we can have this button outside the ControlledModal component determine whether the modal should be shown. So we're going to say onClick, we'll have that onClick event setShouldShowModal to the opposite of shouldShowModal. So it's basically toggling that state variable from true to false, or from false to true. And we can also use this shouldShowModal variable to determine the text of the button, right? Whether it's Show Modal or Hide Modal. So we can say something like shouldShowModal. If the modal's already showing, we want this to say Hide Modal. Otherwise, we want it to say Show Modal. And then what we need to do is just pass in some of the props to our ControlledModal. Remember that those props are going to be something like shouldShow equals shouldShowModal. We have an onRequestClose function, and basically what we're going to do here is just pass in a function that will set shouldShowModal to false, okay? And one other thing that we would be able to do here is we could display an alert or something like that that says, you know, "Are you sure?", that kind of thing before we actually allow it to close. But I'm not going to do that here, so we'll just set it to setShouldShowModal false. We can actually make that a lot smaller if we do it like that. And then, of course, we want to pass children to our ControlledModals. So let's remove this closing tag thing here. There we go. And we'll just have some kind of heading in there. We'll just say Hello for now. All right, so what this is going to look like now, let's head over to our application again. We might have to refresh it here. We're going to say Show Modal, and we can see that obviously the button changes to Hide Modal, although I'm realizing now that we can't really click on it here. But what we can do is click Hide Modal here, and that will call the onRequestClose prop of the modal which we've set in our App component to actually close the modal, okay? So that's what a controlled version of a modal is going to look like. Basically, the modal itself isn't taking care of handling anything about its state. The parent component is the one doing all of that.

### Uncontrolled onboarding flows
-  All right, the last example of controlled and uncontrolled components that we're going to take a look at is onboarding flows. Now an onboarding flow is basically just a component that displays different steps in an onboarding process. So step one might ask for the user's name, step two might ask for their age, step three might ask for their billing information, et cetera. So first let's start off by building an uncontrolled version of an onboarding flow. And after that, we'll see what it looks like if we convert that into a controlled version, and some of the benefits that that provides us with. So we're going to start off here by creating a new component, which we'll call uncontrolled onboarding flow. So we're going to say new file, uncontrolled onboarding flow dot JS, and here's what this is going to look like. We're going to start off by saying import React and useState from React. You'll see how we use those in a second. And our component is going to look like this. We'll say export const, uncontrolled onboarding flow, and it's going to take the children that we pass to it. You'll see what this looks like in just a minute. And it's also going to take an onFinish prop. Now this onFinish prop is basically just a function that's going to get called when the uncontrolled onboarding flow completes. In other words, when it's gone through all of its children that we pass to it, okay? So now we have the body of our component, which is going to look like this. We're going to start off by defining two different state variables. The first state variable is going to be called onboarding data. This state variable is basically going to contain all of the data that we collect from the user over the course of their onboarding. It's basically going to be an object with keys as you'll see in a minute. So we have onboarding data set onboarding data equals useState. The initial value is going to be an empty object. Again, you'll see what that looks like in a minute. And the second state variable we're going to define is going to be the current index of the step that we want to display, okay? So we're basically going to use this to determine which of the children that we pass to our onboarding flow is going to be shown, okay? And this is going to be useState. The initial value is going to be zero. So we're starting on the first child. And once we've done that, we're going to basically get the current child using the current index and this children prop. So that's going to look like this. We'll say const, current child equals React dot children, dot two array children. Basically, this just covers us in the case that children is only a single element where children wouldn't actually be an array, and then we're going to get the current index from children, okay. And before we move on to defining what the JSX of our component is actually going to look like, let's talk about how we're actually going to use this uncontrolled onboarding flow component, basically what it's going to look like. And I'm just going to remove all of the other components that we're not going to be using now, okay? And we'll import our uncontrolled onboarding flow from uncontrolled onboarding flow and display it like this. So basically what this is going to look like is inside our uncontrolled onboarding flow, we're going to have several other components each of which represents a step in the onboarding flow. So what I'm going to do is just define a few very simple components. We'll say const, step one. And we'll return a very simple component that just says step one. And then we'll do steps two and three as well. So we'll have step two, which we'll say step two and step three, which we'll say step three, there we go. So we're going to basically display these step components inside the uncontrolled onboarding flow like this step one, step two, and step three. And our uncontrolled onboarding flow is basically going to control, which of these components actually gets displayed on the page. In other words if the current index is one, it's going to display step two. If the current index is zero it'll display, step one, you get the idea. And let's also remove this should show modal thing here. We don't need that anymore, okay. So now that we know how our uncontrolled onboarding flow component is actually going to work with other components, basically all we need to do is return the current child. Now, the problem with this, this will work if we take a look at this, we'll see that it's displaying only step one, right? Since the current index starts off on zero, but the components themselves steps one, two, and three, don't actually have any way to go to the next step. So there's two ways we could do this one way would be to simply give our uncontrolled onboarding flow. The ability to do that. Let me show you what I mean. We could say return inside React fragments here. We're going to say current child. And then underneath the current child, we could have previous and next buttons. So we could say button previous, and button next, okay. And what that would do essentially is give us the ability to change those there. Basically either by adding one to the current index or subtracting one from the current index, okay. But that's not the approach that I'm actually going to take. The approach that I'm going to take is to pass a prop to each of the children that they can then access. This is similar to what we did with container components. So basically each of these components is going to have access to a prop called something like go to next, which will be a function that they can call to tell the uncontrolled onboarding flow to go to the next step in the onboarding process, okay. So we're going to say, go to next, go to next, go to next. And for each of these components, we're basically going to have it look like this. We'll have a React fragment, and we'll have a button that says on click equals go to next, all right. And we'll do that for all of our steps. So I'm just going to copy and paste step one for steps, two and three, like that. Say step two change this to step two, and step three and change this to step three, okay. And the way that these components are actually going to get this go-to next prop is inside our uncontrolled onboarding flow we're going to define it. So we'll say const, go to next. We'll define that in just a second, but the way this is going to work, just like with container components, we're going to say if React.is valid element, current child, we want to clone that child, and add this go to next function as a prop. So we're going to say return React dot clone element, current child, and the extra prop is going to be this go to next function. And then we'll say return current child. All right and for now, what we're going to do is just have go-to next increment, the current index by saying set current index to current index plus one. All right, so we'll see that this should work if we click on it, obviously when we exceed the index bounds, it doesn't show anything.

### Collecting onboarding data
- [Instructor] Okay. So that's the beginning of our uncontrolled onboarding flow. Next let's take a look at how to work with this onboarding data thing. Basically the onboarding data is just going to contain the data that we've collected in each of our steps. So the first thing we're going to do is modify our go to next function here so that it allows each component, right, each step in the onboarding flow, to pass in some kind of data to it. Okay, so we're going to have an argument here that will be called step data. And the step data is basically just going to be an object that contains some keys and values, whatever keys and values the current step needs to add to the state. You'll see what that looks like in just a second. So let's change the body of our go to next function a little bit. First, what we're going to do is say const next index equals current index plus one. All right. And then we're going to calculate the updated data from our existing onboarding data, and the data that the new step is trying to add. So we'll say const updated data equals dot dot dot onboarding data dot dot data step data, basically just combining those two objects together. Okay. And just for visibility, let's log out this updated data. We'll say console dot log updated data. And then what we're going to do is check if this next index is in the bounds of how many children we have by saying if next index is less than children dot length. If it is, we're going to say set current index to next index. Otherwise what we're going to do is call this on finish prop with the onboarding data that we've accumulated. So we're going to say else on finish updated data. Okay. And we're going to change the set current index here. We don't need that anymore, so we'll just delete it. This is going to be set onboarding data to updated data. All right, so the way this is going to work is each of our steps now is going to call go to next with some object containing whatever data they want to add to the onboarding state. So let's say that step one was supposed to collect the user's name. You can go ahead and add an input there if you want, and a state. Just for simplicity's sake, what I'm going to do is say anonymous function go to next, and we're going to pass an argument there that says name John Doe. For step two, let's say that step two was supposed to collect the user's age. Again, feel free to add an input there and actually do that. But for simplicity, I'm going to just say go to next, and pass age 100. And let's say that step three was supposed to get their hair color. So what we're going to do is say go to next... Hair color brown. All right. So we have our three steps. Each one of those is adding its own data to the onboarding state. And the last thing we're going to do is pass a prop to uncontrolled onboarding flow called on finish. And basically when our flow finishes, what we're going to do is just console log all of the data. And maybe we'll also display an alert saying that you finished onboarding, or something like that. So we'll say alert onboarding complete. All right. So let's see what this looks like. We're going to go back here and click on next. Oh, and let's open up our inspector window so that we can see how the state updates as we go along. So we can see right now that the state now has a property name equal to John Doe that was added by step one. We're going to click next on step two, which will add the age to the onboarding state. All right, so we see that this is what the onboarding state looks like now. And finally, we're going to click on next on step three, which will log out the updated state, as well as display onboarding complete, all right? So one of these, keep in mind, is coming from the go to next function. The other one is coming from the on finish function that we have here, so we're console logging that data. Now again, this onboarding component is considered to be uncontrolled because the app component that's displaying it really has very little control over what it's doing. So again, let's say that we wanted to show and hide certain steps based on the data contained in the uncontrolled onboarding flow. Currently, there's really no way to do that, and that's why we're going to take a look at how to make this onboarding flow controlled.

### Controlled onboarding flows
- [Instructor] Okay, so we've seen how to create an uncontrolled onboarding flow component. Let's take a look at how we can convert this component into a controlled component. So the first thing we're going to do is create a new file for our controlled onboarding flow component, which we'll, of course, call ControlledOnboardingFlow.js. And inside here, what we're going to do is copy and paste all of the code from our uncontrolled onboarding flow. And we'll start off by changing the name here to Controlled Onboarding Flow. And just like we saw with our modal component, the main change we're going to make here is, instead of keeping track of the onboarding data and current index inside the onboarding flow itself, we're going to pass those things in as props from the parent component. So in addition to having children and on finish as props, it's also going to take a current index prop and an on next prop. All right, so you'll see how the onboarding data and current index change here. We're going to remove these two state variables and we can get rid of use state here as well. And the next thing we're going to do is, instead of having all this go to next logic inside our controlled onboarding flow, we're going to move that up into the parent component, which, in our case, is going to be the app component. So let's copy that, and we'll paste it in here. And we're also going to need to add some state variables to our app component. So let's import our use state hook from react, and we're going to create the same two state variables that we had inside our uncontrolled onboarding flow. In fact, we can just copy and paste those from there, actually. We're just going to copy these two, put them in our app component. And we'll come back and fix some of the stuff in go to next in a minute. But what we're going to do first is change this from uncontrolled onboarding flow to controlled onboarding flow. Okay, controlled onboarding flow. And we're also going to simplify this go to next thing here. What we're going to do is simply say set onboarding data to current onboarding data, so onboarding data and step data, we're just using the spread operator there to combine those two. And under that, we're going to say set current index to current index plus one. Okay. And let's also change the name of go to next to just on next, and we'll pass it to our controlled onboarding flow. So we're going to delete those props there. We're going to pass in the current index, since we have that as a state variable now in our app component, so current index equals current index. Oops, I imported something accidentally. And we're also going to pass on next to the on next prop of our controlled onboarding flow. And then, what we're going to do is really simplify the go to next function from our controlled onboarding flow. We're going to remove the entire body and change that to simply call the on next function that we're getting passed in as a prop here. So we'll say on next and call that with the step data. And this go to next, of course, is getting passed to all the children, so that's going to work exactly the same way, and we should be good to go now. If we go back to our app and click on Next, we should see that it works just like before. Now, the benefit of having this as a controlled component, as I mentioned before, is that it gives us much more control over certain changes that we might want to make to the onboarding flow. So as an example, we're collecting the user's name, age, and hair color. What if, based on their age, we wanted to tell the user whether they qualified for our site's senior discount or something like that. Well, here's what that would look like. I'm going to add another step in between the old step three and step two, we're going to change this last one to step four. Okay, and in step three, we're not going to pass anything to go to next. We're just going to pass an empty object here. And we're going to say something like, "congratulations, "you qualify "for our "senior discount," something like that. Now, we obviously don't want to show this step to users who are under a certain age. I think in America, it's 62 or something like that. So what we can actually do, because our app component now has access to the current state of the onboarding, what index it's on and the onboarding data, what we can do is, we can only display step three if a certain condition is met. In our case here, and we're going to add step four there as well, in our case here, we can say something like if onboardingData.age is greater than or equal to 62, then we want to show step three. Otherwise, we want to skip straight to step four. So what's going to happen now, because we're setting age to 100 in step two, we should see step three show up. So I'm going to just refresh this so we go back to step one and I'm going to click Next, Next, and we, of course, see step three and click Next and go to step four. However, if we change this now to something less than 62, if we say 50, for example, and refresh, we're going to see that we'll skip straight over step three. So essentially, what this controlled onboarding flow gives us is much more flexibility over what our onboarding flow looks like and how it changes as we go on.

### What are higher-order components?
- [Instructor] All right, the next React design pattern that we're going to take a look at is something called higher-order components. Now, higher-order components are basically components that instead of just returning JSX, they return another component. That might sound like somewhat of a confusing topic at first, so let's take a look at the basics behind how it works. So as everyone should know, most components in React simply return some sort of JSX, which represents the DOM elements that that component wants to be rendered in its place. However, with higher-order components, as I said, they return a component which then returns JSX. So basically what we're doing here is adding an extra step inside of it. Now, if that still sounds confusing, just remember one thing for now before we take a look at our examples, and that is that higher-order components are just functions that return components. So if you want to think about them as sort of component factories, right, functions that you can call to create new components, if that works for you, then go ahead and think about it that way for now. So the next question is why would we want to actually create these higher-order components? Well, one thing that higher-order components are used for is sharing behavior between several of our components, right? And this is actually a lot like what we saw with our container components, how we were able to wrap different types of components in the same container and have them behave somewhat similarly. So higher-order components allow us to do something similar to that, as you'll see. Another thing that they're used for is to add extra functionality to an existing component of ours. So if we have an existing component that someone else built, what we can do is use higher-order components to add new functionality to that component.

### Printing props with HOCs
- [Instructor] All right. So for our first example of higher order components, what we're going to do is create a component that will allow us to automatically print out the props from different components. So, first of all, you're going to want to copy the starting state from the exercise files, since it's different than what we saw before. Namely we have our server dot JS file, which is back again from when we last used it. And we also have a few of the old components that we've built previously, such as user info. Okay. So what we're going to do is we're going to start off by creating a new file and we'll call this file, print props dot JS. So this print props thing is going to be a higher order component. Let me show you what it looks like exactly. We're going to start off by saying export const print props equals, and this is going to be a function that takes a component as an argument. Okay, so it's going to look like that. Now, one thing that I want to point out before we move on is that higher order components don't normally follow the same convention as regular react components, having a capital letter at the beginning of their variable name. And the reason for that is that with higher order components, we almost never actually display them inside JSX directly, right? So we'll never display this print props component inside JSX like that, which is why we don't need to start it with a capital letter. So now that we have that component define, what we're going to do is return a new component. Okay, so we're going to say return, and this component is going to look just like a regular component would look. In other words, it's just going to be a function. Okay, and it's going to take the components props, like that, and return some JSX in its place. Namely, we're just going to display the component that we passed in as an argument with all of the props passed through from the component we're returning. Okay, so essentially this unnamed component here that we're returning from print props is simply going to display the component that we passed in when we first called our higher order component here. Now, in order to make this print props higher order component live up to its name, what we're going to do is print out the props inside this component that we're returning. So we're going to say console dot log props, and that's all there is to it. So now that we have this higher order component, how do we actually use it? Well, in order to see that let's open up app dot JS, and we're going to say import print props from print props. And we're also going to import this user info component, which we've seen earlier in the course. So we're going to say import user info from user info. Okay, now the way that we're going to use this print props higher order function is we're basically going to create a wrapper around our user info component. And that wrapper will automatically print the props that are getting passed into it. Here's what I mean by that. We're going to say something like const user info wrapped we'll call it, equals print props, and we're going to call our print props higher order component, passing the user info component as an argument. Okay, so this user info wrapped thing now is this component that we're returning from our print props function. It's almost as if we were to say export const user info wrapped equals this thing right here. That's essentially what we're saying in our app file here, when we're saying user info wrapped equals print props user info, okay? All right, so the way that we're going to display this user info wrapped component now is simply using JSX syntax like this. We're going to say user info wrapped and let's just pass a few different props to it. It doesn't have to be any of the props that user info is expecting per se, right? We don't have to pass in user. We can just pass in a prop called a, which will be number one. We'll pass in another prop called b, which will be a string that says hello. We'll pass in another one, c, which is going to be an object I guess, with we'll say name, Shaun, that kind of thing. And what we're going to see now, if we run our code and you don't need to run the server file for this yet, we'll get to that later. We're going to say NPM run start, and that's going to display our user info component, right? And it's displaying loading just because of what we did earlier, where we displayed loading if user didn't exist. Okay, so ignore that part. What we're interested in here is the higher order component that we created, which is automatically displaying the props that we're passing into it. So we can see that we have a one, b hello, c, which is an object with name equal to Shaun. So this print props thing has been a very simple example of a higher order component. And the cool part is that it can obviously be used for things that are a lot more useful than printing props.

### Loading data with HOCs
- [Instructor] All right. So now that we've seen the basics of how to create higher order components, the next thing we're going to take a look at is how to use higher order components to load data and give that to components. This is going to be pretty similar to what we saw before with container components. So what we're going to be doing is creating a higher order component called with user that will basically take care of loading user data from the server and passing it to the component that we wrap it with. So let's start off by creating a new file here called with user dot JS. And here's what this component is going to look like. We're going to say import react, use state, and use effect from react. And we're also going to import the Axios package that we saw before. Just say, import Axios from Axios. We're going to be using that to load data. And then we're going to say export const with user. And just like we saw with our print props higher order component, this with user higher order component is going to take a component as an argument. Okay, and it's also going to take another argument, which will be the ID of the user that we want this higher order component to load. All right, and then what this higher order component's going to do is return a component that simply takes the props object. You'll see how we use that in just a second here and inside here, we're going to have a state variable, which is going to be the user that we want to load from the server. So we're going to say user set user equals use state. The initial value of the user is going to be null, we're going to load the user with a use effect hook where we'll say async and we're going to get the response by saying constant response equals await Axios dot get. Inside back ticks here, we're going to put the URL of the user's end point. So we're going to say slash users slash and then the user's ID. Okay, and under that, we're going to say set user to response dot data. And then we're going to call this async function by putting parentheses after it. Okay, so that is our use effect hook. The only thing we have to do now is return the original component that we passed in as an argument to our with user higher order component with this user state as an additional prop. Now, the way we're going to do that, we don't actually have to clone the element as we saw before, because we're passing in a component and not a react element. So what we're going to do is say return component. We're going to pass in the original props. So the component we create by calling with user is going to behave exactly like the original component, except with extra user loading capabilities. And to add the user prop to this component, we're going to say equals user. Okay, so we're taking all of the original props and adding our own user prop. And that's pretty much all we need to do. So now that we've created our with user higher order component, let's go into our app component and see how it works. We're going to start off, obviously, by importing the with user higher order component we just created. And then just like we did with print props, which I'm going to just remove here, we're going to say const user info and we can call it user info wrapped, user info enhanced. I'm going to call it user info with loader. And then we'll say equals with user and wrap our original user info component. Okay, and then we just have to display our user info with loader component that we just created by saying user info with loader. We don't have to pass any props, but what we do have to do, I almost forgot this, is pass in the ID of the user we want to load as the second argument here. So let's just load user number 234, right? The user with ID 234. What we're going to do, we're going to need to actually run the server before this will work. So I'm going to open up another terminal and we can run the server remember, by saying node server dot JS. And there we go. So let's head over to our app and we'll reload it. We have the user with ID 234 loaded from our server through the use of a higher order component called with user.

### Modifying data data HOCs
- [Instructor] Okay. So now that we've seen how to load data with a higher order component. The next thing we're going to take a look at is how to take this one step further and allow our higher order components to also edit server data. What we're going to do is let's say that instead of just having a user info component that displays the info of a user. Let's say that we have another component, which we'll create right here called user info form, which allows us to edit the information of a user on the server. Now, if you look back in the server.js file, you'll see that we have end points that will allow us to edit the user as well, right? These are post end points as you'll see. So we're going to come back and implement our user info form shortly. But before we do that, let's create a new file, which will be our higher order component. And we're going to call this higher order component with editable user. And the basic idea of this higher order component is that in addition to loading the user from the server and passing it to the component that we wrap with it, it's going to allow the component that we wrap to change that resource through several other props that it'll pass to it. You'll see what I mean in just a second. So to start off, we're going to import react, use state and use effect from react. And we're also going to import axios from axios, which we'll be using to make network requests. And then we're going to export our with editable user higher order component, which is going to take a component as an argument, as well as the ID of the user that we want to load the information for and edit. And then just like we've seen before, we're going to say return props. And this is going to be the component that we're returning here. So this component is going to have two state variables. The first state variable will be called original user and set original user. And this is going to represent the data that we have on the server side, right? So as we make changes to the data on the client side, we'll want to have a backup copy of the server side data in case we want to reset to that original data. I'll show you what that looks like shortly. So we're going to use a use state hook here now. The initial value of that state is going to be no null while we're loading the user. And the next state is going to be called user and set user. And this is going to be the current data that we're editing on the client side. So we're going to say use state, the initial value for that is going to be null as well while we load the user data. All right, next up, we're going to use our use effect hook. Inside here we're going to have an async function. And before I forget, let's add an empty array to this one. I think I might've forgotten that in our with user higher order component as well. So we'll go back in there and add that, just to avoid this use effect hook firing every time the component updates. Okay. So back in our with editable user higher order component, we're going to load that data. This is going to look exactly like what we've seen before. We're going to say const response equals await axios.get. And the URL here, which we're specifying in back ticks is going to be users slash user ID, right? That's the user ID argument that we passed in up here. Okay. So now that we have our response, we're going to set both the original user and the user state variables to the response data. So we're going to say set original user, response.data, and set user response.data. And then we're going to call this async function like that, by putting parentheses after it. And then just like we did in our, with user higher order component, we're going to say return. And we're going to return the original component that we passed in as an argument with all of the props and one additional prop, which is going to be the user that we've specified here. We're going to say user equals user. Okay. So just passing that state variable through. So currently our with editable user hook is exactly the same thing almost as our with user higher order component. What we're going to do though, is add a few more functions in here that will actually modify the user data on the component when certain functions are called. Let me show you what I mean by that. We're going to start off here by specifying an on change user function. And this is going to take the changes as an argument, right? It's going to be an object containing the things that we want to change about the user. And what this is going to do is say set user, and we're simply going to apply those changes to our user state up here, by saying, dot, dot, dot user, dot, dot, dot changes. All right. So that's going to combine the current state of the user with the changes that are passed to this on change user function. Okay. And now that we've defined this function, we're going to pass it to this component as a prop. So we're going to say on change user equals on change user. Okay. We're going to have to specify this on change user as a prop in our user info form when we implement it. All right, so that basically will make changes to the state, but we also want to have a function called on save user. That's basically going to write these changes to the server, right? It's going to make an actual server request that will persist these changes on the backend. So for that, we're going to say, const on save user equals, and this one isn't going to take any arguments. But it is going to be async. So we'll say async. And inside here, what we're going to do is make a server request by saying constant response equals await axios.post. The URL we're going to be making a post request to here is the same one as we made the get request to, so slash users slash user ID. And we're going to want to include a request body here, which will contain the updated user that we want to write to the server. So for that, we just put an object here and add the user there. And if you take a look at the actual end point that this is sending request to, you'll see that it basically just takes this user and modifies its in memory database to make that user persistent. Okay. And now that we have our response, this response here is actually going to contain the updated user from the server. You can see that if you take a look at the end point again. So all we need to do is we want to set our original user to that updated user and set our user state to that response.data as well. Okay. You'll see again, what this original user thing is in a second. All right. So we've specified this on save user function. We're going to pass that as a prop as well to this component. So we're going to say on save user equals on save user. And the last function we're going to define here is going to be called on reset user. And what that's going to do is simply reset the state of our user here to the state of our original user when we first loaded the user from the server. Okay. So that'll be used if, you know, the user is editing something in the user info form and they want to reset it to the way that it was before. Okay. So all we need to do for that. This is what the original user state is for in the first place. We're just going to say set user and set the user to the original user. Okay. And then let's pass through on reset user as a prop to this component as well, on reset user equals on reset user. And that should be all we need to do.

### Creating forms with HOCs
- [Instructor] So we have our width editable user higher order component all set up. So what we're going to need to do now is create this user info form. This should be pretty simple to implement. What we're going to do is we're actually going to import our width editable user higher order components. So import with editable user. And then we're going to say export const user info form. Now, before I go any further, what I want to say is that so far, whenever we've wanted to use a higher order component, we've specifically created a separate component without that functionality. Let's say user info, for example. And we've explicitly wrapped that with our higher order component and created another named component from that. Now, that's perfectly fine to do, and it definitely makes it nice and readable when you're using it. But what you're also allowed to do is simply use this higher order component when you define another component in the first place. What I mean by that is we're going to say export costs user info form equals with editable user. Okay, and then we're going to define our user info form component directly inside this with editable user components arguments. Okay, so it's going to look like this. We're going to take the props, which will be user on change user, on save user, on reset user and believe that's all we need there. And then inside here, it's just going to look like a regular component. We're going to start off by getting the basic information from this user. So we'll say const name, age, and hair color equals user, or since the user can be null, we're just going to put an empty object there to avoid JavaScript errors. And then we're going to say return. And if the user has loaded, we're going to basically return a form that will allow us to edit each of these pieces of data. So we'll have name like that, and this will be an input with the value equal to name and on change now, instead of having a use state hook inside our user info form component that we're defining here, we're actually going to call this on change user prop that the higher order component has already defined for us. So what that's going to look like, we're going to say e and we're going to call on change user with a changes object, which is just going to be an object containing the properties we want to change. And we're going to say change the name of our user in the higher order component to e dot target dot value. Okay. And that's basically all we need to do. So that's the name input, and this could be a label as well. It's probably better to make that a label. Label. Okay, that's just the more correct react way of doing things. And then we'll do the same thing for the users, age and hair color. Okay, so we'll have age, the type of this will be number. The value will be equal to age. And for on change, we're going to call on change user, except instead of having name here, we're going to set it to age and we need to coerce this into a number since by default, all values coming from inputs are going to be strings. So we'll say number and convert that into a JavaScript number there. Okay, and the last one is going to be the hair color. So let's change this to say hair color, okay. The value is going to be hair color and for on change, the property is going to be hair color, and that is going to be set equal to e dot target dot value. Okay, so currently the value of each of these inputs is linked to the value of this user object through this on change user prop that it's getting passed from the higher order component. So the last thing we're going to do in this user info form is add an on save user and on reset user, buttons. Okay, so down here underneath all of our inputs, we're going to add a button for resetting the user, right? This will basically reset all of the values back to what they were before we changed the input values. So we'll say button on click equals on reset user. And this button will say reset. And we'll have another button who's on click method will call on save user. And the text of that button will be save changes. Okay, and then since we're expecting this user to be loading at some point, we're just going to add another clause to this turnery operator that just says loading inside paragraph tags. All right, and since this with editable user higher order component expects a second argument, which is the ID of the user, we need to add that as well down here, right? So this big, first argument is the component that we're wrapping. The second argument is the URL that we want to make these requests to. So we'll just say slash users slash 1, 2, 3, and that should be all we need to do. So let's go into our app component now. We're going to import our user info form. Remember that our user info form is already wrapped in a higher order component. So we don't need do that inside this file. User info form, okay. And we're just going to display it right here. We'll say user info form like that. And let's head over to our app and see if it works. Oops. It looks like I mistyped the URL here. Let's go back. Oh, and this just needs to be the user ID, not the actual URL, okay? So we'll just pass 1, 2, 3 there. All right. So if we refresh our page, we're going to see that we have our form, which says John Doe, age 54, hair color brown. This data was all loaded from the server, right? Let's say we change the hair color and click on save changes. That change is actually going to be persisted in the server. So if we refresh this, we'll see that it doesn't get reset. Now this reset button, the way that that works is if we change all of these to some other value, and we want to go back to what those values were that we got from the server originally, we can just click on reset and the higher order component will take care of resetting all of that for us. So hopefully this has all made sense, and hopefully you can also see why this with editable user thing is so useful, right? Basically this allows us to create any kind of component, right? We're not just limited to our user info form here. It allows us to create any kind of component that might need to make changes to a user on the server.

### Higher-order component improvements
- [Instructor] All right, so now that we've seen how to create a withEditableUser higher order component, we're going to take this one step further and create a withEditableResource higher order component. This will be kind of similar to what we did earlier in the course when we created a container component that did the same kind of thing. So, here's what this is going to look like. We're going to start off by creating a new file for this higher order component which we'll call withEditableResource as I said. And we're going to start off by copying and pasting the withEditableUser higher order component. So we're just going to be making this a little bit more generic and reusable. So first of all, let's change the name of this higher order component to withEditableResource. And the next thing we're going to do is change the arguments a little bit. So it's still going to take the component as its first argument, the component that we're trying to wrap and then pass props to. But as it's second and third props, instead of taking a userId, since we're going to be working with resources instead of just users, we're going to be working with any kind of data, we're just going to specify the resource path, that is the path on the server, and we're going to specify the resourceName. This is again similar to what we did earlier with container components. So the next thing we're going to do is just kind of make a few name changes. We're going to change originalUser to originalData and change this as well since we're not just dealing with users anymore and we're going to change this to data and setData. Okay and now that we've made those changes, we're going to go through and change the logic inside the useEffect hook. So instead of having our user's endpoint hard-coded here, we're going to say axios.get resourcePath. That's going to be the server endpoint there. We're going to say setOriginalData response.data and setData response.data to reflect those name changes we made. And then what we're going to do is go through each of these three functions onChangeUser, onSaveUser, onResetUser and make those more generic as well. What I'm going to do specifically is change this to onChange, onSave and onReset. Okay and then we're going to have to make these name changes in here as well. So setData, data and changes, setOriginalData and setData. And this URL here is going to have to change to our resourcePath. So resourcePath and then instead of passing the prop named user, we're going to have to actually specify the resourceName that we passed as an argument up here. So the way we're going to do that is in square brackets, we'll say resourceName. And then after that, we'll say data. Okay? And finally we have onReset which we just have to change to setData and originalData like that. And now comes the kind of tricky part. What we need to do, obviously we want to allow ourselves to pass in on changeUser, onSaveUser onResetUser. We don't just want to shorten each of these to onChange, onSave and onReset. And the reason for this is because there may be situations where we want to use the same higher order component several times over again. Let's say that we were building a component that needed to use both user data and product data from the server. Basically what we would do is wrap that twice with withEditableResource, right? We'd say withEditableResource and then withEditableResource again and then we would wrap some component. We might say HomePage or some component like that. And the first resource would be, you know our products and the outer resource here might be our users, something like that right? So in that case, we would need the onChange, onSave, onReset to have names such as onChange user or onChange product. So the way we're going to do that is we're actually going to create a separate object here called resourceProps. And we're going to use what I would call a little bit of ninja JavaScript to make this happen. So specifically for the first prop, that prop is going to have the name equal to the resourceName argument that we passed into our higher order component up above. So in this older case, we just said user equals user. For this one, we have to say resourceName and specify that for that one, we want to pass through the data state. And then we're going to do the same things for onChange, onSave, onReset. The tricky part with these is that we have to actually add on onChangeUser, onSaveUser, onResetUser or whatever the resource name is to the end and we have to capitalize that. So the way that we're going to capitalize that string is by defining a capitalize function up at the very top of our component file. And this is going to be where the ninja JavaScript comes in. We're just going to say that this function takes a string and we're going to say string.characterAt(0).toUpperCase plus string.slice(1). Okay, basically all this does is it capitalizes the first letter of a string. Don't worry too much about the JavaScript details there if you're not super strong in that. So, now that we've done that, what we're going to do is specify the other prop names inside this resourceProps here. What we're going to do, we're going to use square brackets and say onChange. And then into this template string, we're going to insert the capitalize resourceName, so capitalize resourceName, and that's going to be our onChange function that we defined above. And then we're just going to do this exact same thing with onSave and onReset. Okay so onSave, onReset and we're going to change these as well. And that should really be all we need to do. The last thing we're going to do is just replace all of these user onChange, on Save, et cetera, and pass the new resourceProps that we've defined there to our component. So we're going to say resourceProps like that and that should be all we need to do. So let's see how this thing is going to work. Oops and I accidentally deleted a curly brace there. So the way this withEditableResource component is going to work is we're going to go into our userInfoForm component that we had from earlier. And instead of using withEditableUser, we're going to change this to withEditableResource. So let's say import withEditableResource, change this here to withEditableResource. Okay and the props that we're destructuring inside the component are going to be exactly the same Because we're going to pass in the resourceName and resourcePath which will be taken by our withEditableResource higher order component and converted into onChangeUser, onSaveUser, onResetUser and so on. So now we just need to change the final props that we're passing to this higher order component. First we need to pass in the path of the resource we want to load which is going to be /users/123 and then we just have to pass in the name of the resource which is going to be user. All right, so let's see if this thing works now. Make sure you have your frontend and backend both running and we'll head over to here and refresh. Sure enough we see that it correctly loaded the data for us. And if we try and change this now, we'll change a few of these properties here. Give John blue hair, click on Save Changes. And if we refresh now, we'll see that those changes were persistent on the server. And we can also see that reset works if we just make a few random changes to these things here. Click Reset, that will reset all of those things to what they were before. So as you can see, everything is working just like we had it with our original withEditableUser, except now we can change basically any kind of resource, be it products, users, articles, anything that we need to. So that's the real power of higher order components in React.

### What are custom Hooks?
- [Instructor] All right, the next React design pattern we're going to take a look at is the pattern of custom hooks. So, what are custom hooks? Well, custom hooks are basically when instead of just using the basic hooks that React provides us with, such as useState and useEffect, we actually combine these hooks into our own new hooks. So, what this might look like is, let's say we want our component to have access to products from the server. Well, we could either create the product state and actually load the products inside the component itself, or we could create our own custom useProducts hook that encapsulates this functionality. We're going to see how to do this very shortly, but this that you see here is what custom hooks will generally look something like. When we use custom hooks, right? Once we've created our custom useProducts hook, useUsers hook, whatever kind of resource or functionality we're trying to encapsulate in that hook, the way we use it in our component is usually like what you see here. We just say const products = and then our custom hook. And one thing to note is that custom hooks do have to start with the word use, okay? That's just something that React requires us to do and it has to do with the way that hooks work behind the scenes, but we won't get into that right now. So, custom hooks are used for pretty much the same thing that we've seen with higher-order components and container components. They're used to allow us to share complex behavior between several different components, right? Like what I said before, if we want to, say, load products from a server, instead of having to specify that same loading logic over and over again, we can put that logic into a custom hook and simply use the hook in each of our components.

### useCurrentUser Hook
- [Instructor] So now that we know the basics behind custom hooks in React, let's see what they actually look like and how we can add them to our React applications. For this example, we're going to be doing, basically, the same thing that we've done before with our container components and our higher order components. We're going to start off by seeing how to load a current user from the server, and, by the way, you're going to want to get the starting state of this from the exercise files if you're following along. So we're going to start off by seeing how to load the current user from the server, and then we're going to expand this to be able to load any user from the server, and this will be followed by seeing how to load different resources, and, finally, we'll top that off by seeing how to create custom hooks that can work with any kind of data source. So, again, similar to what we did with container components. So, to get started, you're going to want to, first, run the server by saying node server.js, and then we'll open up another terminal, or just another tab in your terminal, and run our React app by saying npm run start. Okay, and now that we have both our front-end and back-end running, let's create a new file for our first custom hook. Now remember that custom hooks need to start with the word use, so we're going to call this custom hook useCurrentUser. And what it's going to do is allow whatever component uses it to have access to the current user that we're going to load from the server. So let's create that file, and our custom hook is going to look something like this. We're going to say export const useCurrentUser, and custom hooks are really just functions that call other hooks. So the next thing we're going to do is import a few things up at the top. We're going to start off by importing useState and useEffect from React. And we're also going to import axios, since we'll be loading some data from the server here. Okay, and let's create a user state variable, here, by saying const user, and setUser equals useState, and then, just like we've seen before, we're going to have the initial value of our user be null while we're loading it. And then we'll use our useEffect hook to, actually, load that user. And let's make sure to add an empty array as the second argument so that it doesn't get called every time the component, that's using this custom hook, updates. And inside this useEffect hook we're going to create and call an asynchronous function, like this. And this is going to be just like what we've seen several times already, we're going to say const response equals await axios.get. The endpoint, for the current user, is going to be /current-user, and under that we're going to say setUser to response.data. Okay, and let's call this asynchronous function. And the last thing we need to do, now, is define what the component, that actually calls this custom hook, is going to have access to, right. In other words, what data are we going to give it? And, to do that, all we have to do is say return user. So this, basically, means that when another component uses this useCurrentUser hook, it's going to look like this. They're just going to say const currentUser equals useCurrentUser, and this value will be equal to the current state that we have for user inside our custom hook. All right, so that's pretty much all we need to do for this custom hook. Now let's see how to use it. So we have our Userinfo and Productinfo components that we created earlier in the course. So let's open up our Userinfo component and see how to add this custom hook. Okay, so when we created this component earlier we made it so that user was passed in as a prop, so that's usually from the parent component. Now, this is often what we're going to want to do since we'll want Userinfo to be able to display different users based on where it's being displayed in the page. However, just to get a feel for how this useCurrentUser hook is going to work, I'm going to remove this prop for now. Okay, so we see that we're getting the red underline under user. What we're going to do now is import this custom hook. We're going to say import useCurrentUser from useCurrentUser, and, up here at the top of our component, we're going to say const user equals useCurrentUser, and that should be all we need to do. So let's just display this Userinfo inside our app component now. All right, so we're going to import it, import Userinfo from Userinfo, and then display that component inside our app component by saying Userinfo. And now, if we go back to our browser, we're going to see that the current user, which is in our current user endpoint on our server, is displayed inside the Userinfo component. So that's how you create a very simple custom hook in React.

### useUser Hook
- [Instructor] We've seen the basics now of creating custom hooks. What we're going to do next is take our useCurrentUser hook that we created and modify it a little bit so that we can make it load any user we want from the server. Here's what this is going to look like. We're going to start off by creating a new file. We'll call this file useUser.js. For the code here, we're going to start off by just copying and pasting our useCurrentUser custom hook that we created. There we go. The changes we're going to make are going to look like this. We're going to start off, of course, by renaming our custom hook to useUser. This custom hook, since, remember that custom hooks are just functions. This custom hook is going to take an argument, which will be the ID of the user that we want to load from the server. From there, really, the only other thing we have to do is change the URL that we're sending this request to. We're going to use back-ticks and say /users/ and then insert the userId argument into that URL. Then we just need to add userId to the useEffect array argument here so that basically this useEffect will refresh and re-load the user if the ID of the user changes. That's pretty much all we need to do. Let's go back now to our UserInfo component and take a look at how to actually use this useUser custom hook. When we used useCurrentUser, I pointed out that this does make this component a little bit less flexible. Since we're no longer able to pass in whatever user we want, we're pretty much constrained to just having the current user here. But what we can do, now that we have a useUser custom hook, is we can import that one instead. We're going to say import useUser from useUser. Then we're going to use the useUser custom hook instead of useCurrentUser. The way that we're going to get the user ID that will pass in to the arguments here is through a prop that will be passed to UserInfo. This will allow us to basically re-use this UserInfo component for different users since we'll just be able to render UserInfo with different values for the userId prop. Now that we have the userId prop, we're just going to pass that through to our custom hook. Then going back to our app component, we're going to see how we should do this. We have UserInfo imported already. Let's just display several UserInfo components with different user IDs. The first one here will have user ID 123, the second one here will have user ID 234, and we'll have one more, which will be for user ID 345. That's all there is to it. Let's take a look now at our app, and we see that, sure enough, our UserInfo component is using that custom hook that we created to load three different people from the server.

### useResource Hook
- [Instructor] Okay, so we saw how to refactor a custom hook to make it more reusable with our useUser custom hook. Let's take this a step further now and create a custom hook that will allow us to load any kind of resource. So here's what this is going to look like. We're going to start off by creating a new file, and we're going to call this custom hook useResource.js. And, again, we're going to start off by just copying and pasting the state of the last hook that we created, okay? And we're going to make a few changes here. So, first of all, let's change the name of this custom hook to useResource like that. And then instead of having our state variable be called user, we're just going to have it called resource and setResource. And then down here what we're going to do is instead of sending a GET request directly to the /users URL, we're going to remove that and allow ourselves to pass in the URL that we want to load the resource from as an argument to our custom hook. So the argument here, we'll call it resourceUrl, and then we'll simply pass that URL to axios.get, okay? And then we just have to change this to setResource, change userId here to resourceUrl, and change return user to return resource, okay? So what we're able to do now is use this useResource custom hook in a pretty similar way to how we used our useUser custom hook, except with useResource, here let me show you what it'll look like if we import it and then use it down here. We're going to say const user equals useResource, and all we have to do here is just pass the URL of the resource. So in our case here, that's going to be /users/, and we'll pass in the userId prop like that. Now, this should work exactly like it did before, right? We see that nothing is changed. But the nice thing about this useResource custom hook now is that we can use it to load basically anything else we want. So let's open up the ProductInfo component that we had from earlier and see how we can use the useResource custom hook to load products as well. So let's start off by importing useResource from ./useResource. And what we're going to do is instead of passing in the product as a prop to ProductInfo, we're just going to pass in the productId. We're going to use this in exactly the same way that we did with the UserInfo component. So here's what this will look like now. We're going to say const product equals useResource, and then we just need to specify the URL of the product that we want to load. So that's going to be /products/, and we're going to insert the productId into there like that, and that's all there is to it. Let's head over to our App component now, and we can leave the UserInfo components where they are. In fact, let's just remove one or two of them so we can see the ProductInfo one more clearly. Let's import ProductInfo up the top here, import ProductInfo from ./ProductInfo, and display it by saying ProductInfo. And for the productId, let's just pass in one of the IDs that we have on our server such as 1234. Okay, so let's take a look at this and see if it worked. Ah, it looks like in ProductInfo, we just have to add something to make sure that product actually exists. So we'll add that there like that, and that should be all we need to do. So we see that our product is indeed being displayed. And, really, all we had to do to add that functionality to this ProductInfo component was use this useResource custom hook that we created, right? So this is much easier than the way that most React developers would normally go about it, which would be to basically import useState, create a new state hook here by saying const product, setProduct, et cetera, right? And then actually using a useEffect hook directly inside the component. So to sum all that up, this useResource custom hook allows us to quickly and easily load any server-side resource inside any component.

### useDataSource Hook
- [Instructor] All right, so we made our custom hook, very, very reusable and flexible by creating this useResource custom hook. What we're going to do here is take it one step further and allow ourselves to specify any data source for our components, with a custom hook. This is going to be very similar to what we did earlier with our container components. So let's start off by creating a new file for our new hook here. And we're going to call this new hook, useDataSource.js, and as usual, we're going to start off by copying and pasting the last custom hook that we created. And here's what this is going to look like. So instead of specifying a resource URL for ourselves here, what we're going to do is allow ourselves to pass in a function that will specify how exactly to get the data, right? This function is basically going to tell our custom hook where to find the data. So we'll call this function, getResource function, like that. And of course, we need to change the name of our custom hook here. So we'll say useDataSource and we're going to leave everything else pretty much the same, except for this part inside our asynchronous function. What this is going to do is instead of saying await axios.get, which is very specific to loading data from the server, right? We want to make it a little more generic. We're going to say await, getResourceFunction, just like that. Okay, and for setResource, we're just going to say set resource to response. And in fact, let's rename this from response to result or something like that. Since response is also very specific to getting data from a server. Okay, and for the array argument for use effect, we're going to change this to getResourceFunction like that, and we're returning the resource, okay. So let's see how this is going to work now. Let's head over to our user info and let's import our useDataSource custom hook, like that. And then what we're going to do is instead of using useResource, we're going to say const user equals useDataSource. And we're going to want to specify that we want to get the data from the server. Now, the way we do that is we basically pass a function as an argument to our useDataSource custom hook that will contain the logic that we basically removed when we changed this to say a weight getResourceFunction. So we're going to start off here by importing axios, import axios from axios. And what we're going to do is say constant response equals await axios.get, and then we'll say slash users, slash and insert the user ID. Oh, and this should be an asynchronous function here. So say async at the beginning. And then we'll say return response.data, okay. So this response.data that we're returning is the exact location of the data that we're trying to get. Okay, so if we go back to our browser and take a look, we should see that nothing has changed with our user info component. Now at first glance, this useDataSource custom hook probably looks a little more complicated than our useResource custom hook, right? Well, what we could do is specify a new function up at the top here, that will actually create variations of this asynchronous function inside of here for us, right? So if we wanted to do something like load products, instead, we could simply use this function to do that instead of having to type out the same code over and over again. Let me show you what I mean. We're going to say const, and we'll call this function, something like serverResource. All right, and this is going to be a function that returns a function. So serverResource is going to take one argument, which will be the URL of the resource that we want to load from the server. And it's basically going to return this asynchronous function that we defined inside of here. So let's just cut that out and paste it here, okay. And then we're just going to replace this hard coded URL here with the resource URL that we passed in to the first set of arguments. And what this will allow us to do is say use dataSource, serverResource and pass in the URL that we want to load the data from. Okay, so we could say slash users, slash user ID. And this here is much simpler and more configurable than what we saw before, because what we can do, is, again, let's say we have some data in local storage. We could simply define another function here called localstorageResource. We'd specify the key where that resource is stored in local storage. And we would return a function, which doesn't have to be async since local storage is synchronous. And we could simply say return localStorage.get item, key. And that would be all we need to do. So if we wanted to load something from local storage, like if we add a message in local storage, let's say. We could say constant message equals useDataSource, localstorageResource instead of serverResource, and then simply pass in the key, which would be something like message, presumably. Okay, and by having usedDataSource and serverResource separate, what we're able to do is actually have this custom hook with all of its functionality and configure it by passing in other functions that tell the custom hook how to actually get the data. Now, in reality, you might not want to go this far, right. UseResource would probably be a good stopping point, but nevertheless, there are some applications where this kind of thing and having this kind of configurability can be very helpful.

### What is functional programming?
- [Instructor] Okay, so the final topic that we're going to talk about in this course is functional programming and how do we incorporate it into our React applications. Now I don't refer to functional programming as a design pattern, but functional programming itself does lead to some very interesting design patterns in React and that's what we're going to be taking a look at here. So first let's start off with a definition of functional programming. Now, functional programming is a very broad topic, and I do have some courses on that in the library. So if you want to go into more depth here, feel free to take a look at those. But the basic definition that I'm going to give you here is that functional programming is a way of organizing our code base such that we minimize mutation and state change in our applications, we keep our functions independent of external data, this is something called pure functions, and we also treat functions as first-class citizens. Now I realize that this may be kind of an opaque definition for those of you who aren't familiar with functional programming yet. So again, I highly recommend that if you want to get into this more deeply, go take a look at one of my functional programming courses in the library. So let's talk about some of the applications of functional programming in React. Some of the most common applications of functional programming in React are something called controlled components. All right, so controlled components, which we saw earlier in the course, basically the idea of those is that we can get the component into any state we want simply by passing in the right props. So the component isn't keeping track of its own state, and that's a pretty functional concept there. The next application of functional programming in React is function components. Now those of you who have worked with React for a long time are probably familiar with the fact that there are two ways of defining components in React, either as classes or as functions. And as it happens, the act of defining our components as functions is itself, a very functional way of writing code. Next up we have higher order components, which we've already seen in the course. Higher order components because they're functions that return other functions, which is an application of something called first-class functions. This is a great example, actually, of functional programming in React and some of the things that that allows us to do. All right, so we've seen these three pieces already. The next three pieces that I'm going to talk about are the ones that we'll be working on in this section. The first one is recursive components. Recursive components are basically components that use recursion in order to achieve a desired effect. These can be very cool. So I highly recommend that you stay for that video. Next up we have partially applied components. Partially applied components basically allow us to take more general components and by passing in only a subset of that components' props, create more specific versions of that component. Again, take a look at that a little later on. And finally we have component composition. Basically, this is when we take several different components and are able to combine them into one component to achieve a desired effect. And again, we'll look at that later. So those are some of the main examples of functional programming in React. Each of these, as we've seen, forms its own react design patterns. So let's take a look at these last three that we haven't seen yet.

### Recursive components
- [Instructor] All right, so the first functional pattern that we're going to take a look at is recursive components. So again, recursive components are components that refer to themselves inside the body of the component. I'll show you what I mean in just a second here, but first make sure that you have the starting state of the exercise files because it's different than what we had before. So let's get started creating a recursive component, but before we do that, I want you to take a look at the app dot JS file. So notice here that we have this nested object here, and basically it's just an object where some of the properties, like a and b are themselves objects with other properties and those properties might be objects themselves with other properties, okay? So it's a pretty nested structure here. It could go a lot deeper if we wanted it to, but this kind of data, when we're working with nested objects or other kind of nested structures, is usually when we turn to recursive components because they provide us with a unique advantage as we'll see. So let's create a file for our recursive component, which we'll just call recursive component dot JS. And we're going to start off here by saying export const recursive component equals. And this is going to take a single prop called data. So for this demonstration, what we're going to have our recursive component do is take this nested data and display all of the keys, and values that it contains. So here's what this is going to look like. We're going to start off up here by defining a function called is object. And this is basically just going to tell us if the argument that we pass into it is a non null object. So here's what that'll look like. The argument's going to be called X, and it's going to return if type of X is equal to object and X is not equal to null. Okay, so now that we have that function, the first thing we're going to do inside a recursive component is define what's called a stopping case. Basically, this is the case where we will stop recursing and simply return some value that doesn't involve referring recursively to the component itself. So in our case, that's going to be when the data that this component receives is not an object. In other words, when the data that the component receives is just a value of some kind. So what we're going to say is if the data prop is not an object, okay. So if not is object data, then what we're going to do is simply return a list item that contains the data. Okay, so we'll say list item, data, just like that. Okay, so that's the stopping condition, but if data is an object, then what we want to do is get each individual key and value of that object and display another recursive component for each of those key and value pairs. So what this is going to look like is we're going to start off by getting the entries of this data object, because we know that it's an object now after this if statement, and we're going to say const pairs equals object dot entries data, and what object dot entries does is it returns an array of all of the key and value pairs from this object that we have here. Okay, so now that we have those pairs of keys and values, what we're going to do is say return inside here, we're going to have React fragments. And we're going to say payers dot map. And for each key value pair, what we're going to do is get the key and value, which we can do with array de-structuring here saying key and value. And for each of those keys and values, what we're going to do is display a list item, which will contain the key with a colon after it, and inside that we will have a nested unordered list, okay. And here is where our component becomes a recursive component. It's actually going to refer to itself inside the JSX. So we're going to say recursive component and the data that we pass to that recursive component is going to be the value here of that key. You'll see what this looks like when we display this. And it'll all make sense in just a minute. So we're going to say data equals value, and that is our recursive component. So what we're going to do now is display this recursive component and pass this nested object to it and see what it looks like. So let's import our recursive component up at the top. We're going to say import recursive component. And then down here, we're going to replace this with recursive component. And the data that we pass is going to be the nested object. And that's all there is to it. Let's run our React App now with NPM run start. And what we're going to see is that our recursive component has recursively rendered all of the keys and corresponding values of our nested object. So we see a, the value for that is one. And if we go back and take a look at our nested object here, we'll see that that's true. And for b, which is a pretty highly nested portion of this nested object, we can see that it has the three top-level properties and some of those which are objects have displayed the properties and values of those objects as well. So that's what a recursive component looks like. And again, you're generally going to use that when you have some sort of very nested data structure that you need to traverse, like we just did.

### Component composition
- [Instructor] Okay, so now that we've seen how recursive components work in React, the next design pattern that we're going to take a look at is composition in React. So basically composition is the functional programming analog to inheritance in object oriented programming. Now, obviously both have their differences, but we're going to take a look at what composition looks like here in a React app. So let's start off here by creating a file called composition.JS. And this is just going to have a few different components inside of it for demonstration purposes. So let's start off here by imagining that we have a button component. Okay, it's going to be pretty simple. We'll say export constant button and this button component is going to take a few different props. One is going to be size. One is going to be color, that is the background color of the button. And one is going to be the text of the button, and then we'll have the rest of the props that we might want to pass through. Okay, and then our button is just going to return a regular HTML button element with some styles specified by the props that we passed into the button component. And that's going to look like this. We're just going to say style. We'll set the padding depending on the size. So our size is just going to be a string that's either large or small. So we'll say if size is equal to large, we want the padding to be 32 pixels. Otherwise we want it to be only eight pixels. Okay, next we're going to have the font size. And that is also going to depend on the size prop as well. So we'll say size is equal to large. If it is we're going to have 32 pixel font size, otherwise we'll have 16 pixel font size. And finally we'll have the background color of our button and that's just going to be equal to the color prop. And then we'll pass in the rest of the props to our button here by saying dot dot dot props. And finally, we'll insert the text of the button inside the opening and closing tags. Okay, so we have this basic button component. The way we would use that is simply by saying button, then we could say size equals large, color equals red, text equals hello, something like that, right? Well, what composition would allow us to do is actually create different versions of this button by creating components that use it. Here's what I mean by that. Let's say that we want to have both a danger button and a success button in our app. Instead of having to use our button all the time and specify that size equals large and color equals red, let's say. Well, what we could do and the way that composition works is we can simply say export const and call our new components something like danger button, equals, and then we'll get the props and say return our button with all of the existing props and color specifically set to red, okay? Oops, and I spelled button wrong there. Let's fix that. And now that we've composed our button here, all we would have to do in the rest of our code is simply display the danger button and that would automatically have color set to red, right? Now another thing that we could do is if we wanted a big success button, let's say, we could say export const, big success button, and that would do the same thing. Take all of the props and return our button with all of those props and size specifically set to large and color specifically set to green. Okay, now, if we wanted to use both the danger button and a big success button in our app, what that would look like, let's just import those two things, danger button and big success button from composition. And then down here, we could simply display those inside a React fragment by saying danger button. And we would want to specify the text here saying something like don't do it. And we could display our big success button with some text saying yes. And what that would look like if we take a look in our browser is we would have our danger button, which has the background automatically set to red. And we would have our big success button which has the padding automatically set very large, and the background automatically set to green. And the nice part about this is that we don't have to copy and paste this same code from our button component into our danger button and big success button. In other words, both our danger and big success buttons are just building off the code that's contained inside of the original button component.

### Partially applied components
- [Instructor] Okay, so we've seen how composition allows us to create a lot of different versions of components just by displaying that component with some specific props. Now, what we're going to do in this video is take a look at partial application, which is sort of the next step of this case. And what partial application is, is it's a way to allow ourselves to specify a set number of props on a component without having to create a new component like we did here with the danger button and a big success buttons. This is probably just easiest if I show you an example. So let's start off here by creating a higher order component. Yes, we're going to use higher order components to implement this called partially apply dot JS. Okay, and here's what this higher order components going to look like. We're going to say export const partially apply equals. And this higher order component is going to take a component as an argument and a second argument that says partial props and what this partial props thing is going to be is an object that contains some subset of the props that we want to pass to a given component. And what this partially apply higher order components going to do now is simply return a component that takes the props and passes them to the component that we passed in as an argument with dot dot dot partial props and the components actual props. So essentially what this will do is allow us to specify some of the props for a component ahead of time, which is essentially what we were doing in our composition example here. So let's redo our composition example. I'm going to just copy this button component and bring it into our file here. And let's say that we want to create the same danger and success buttons inside of here. Well, the way that we would do that with this partially apply higher order component would be something like this. We could say export constant danger button equals partially apply, and we want to partially apply some props to our button components. So we'll pass that as the first argument. And for the second argument, we're going to pass a key and value for the prop that we want to set in our case, that's going to be color red. Okay, and we can do the same thing for our big success button by saying export const big success button equals partially apply button. And this time we're going to specify two different props. We're going to say color green and size large. Okay, and now if we want to display these partially applied components here, let's head over to app dot JS, and we're going to change danger button, big success button from composition to partially apply. And what we're going to see is that we're still able to pass through this text prop on both our danger button and big success button. And the other two props will automatically have been set already. So let's go back to here and take a look. Oops and it looks like I forgot a return keyword here. So we'll just say return component and let's head back. And we see that now we have the exact same thing, except we're using higher order components to achieve this instead of explicitly creating new components like we did in our composition example here.

### Next steps
- All right, well we've come quite a long way in this course, and learnt a lot of different react design patterns. Just as a brief recap of what we've learned. We learned about layout components and how to use them to organize the components we create on the screen. We learned about container components, which allow our components to share different functionality between them through means of a parent component. We learned about controlled and uncontrolled components and some of the differences between those and why we prefer controlled generally. We also covered higher-order components and some of the things that you could do with those, right? How to use them to add functionality to an existing component. And we also learned about custom hooks. And finally we closed out with some functional design patterns such as recursive components. So now that the course is coming to an end, you're probably wondering where to go next. Well, the main next step that I would recommend for you is to try incorporating these concepts into your own applications. This will both allow you to get a better handle on the concepts we covered, and it will give you a lot of practice so that you can eventually memorize these design patterns and have them become second nature to you. And just as one last thing, if you want to connect with me on LinkedIn, feel free to do so. I'm on LinkedIn quite often, and would love to hear any questions or comments from you directly. So just feel free to send me a connection request there. Well, thank you so much for watching this course, I hope you found it valuable, and I hope to see you in another course.